{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NetBayesABM","text":"<p>NetBayesABM is a Python library for simulating agent-based models (ABMs) of plant\u2013pollinator networks with Bayesian inference (ABC).</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Initialize agents (plants, pollinators) with different spatial strategies.</li> <li>Build and evolve bipartite plant\u2013pollinator networks.</li> <li>Visualize abundances, priors, and degree distributions.</li> <li>Evaluate model vs empirical data using multiple metrics.</li> </ul> <p>\ud83d\udc49 For installation instructions see Installation.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#classes","title":"Classes","text":""},{"location":"api/#netbayesabm.classes--netbayesabm-agent-and-environment-classes","title":"NetBayesABM - Agent and Environment Classes","text":"<p>This module defines the core classes for representing agents (plants and pollinators) and their environments in the  agent-based models (ABM) of plant\u2013pollinator networks.</p> <p>Classes:</p> Name Description <code>Agent_Plant</code> <p>Dataclass representing a plant agent with species information and spatial coordinates.</p> <code>Agent_Pol</code> <p>Dataclass representing a pollinator agent with species information,  spatial coordinates, and an interaction radius. Includes a method for random movement.</p> <code>Environment_plant</code> <p>Container class that builds a list of <code>Agent_Plant</code> objects from a DataFrame. Supports three modes of plant positioning:  - as provided in the DataFrame - random within spatial boundaries - regular grid within spatial boundaries</p> <code>Environment_pol</code> <p>Container class that builds a list of <code>Agent_Pol</code> objects from a DataFrame.</p> Typical workflow <ol> <li>Load empirical plant and pollinator data into pandas DataFrames.</li> <li>Initialize agents with <code>Environment_plant</code> and <code>Environment_pol</code>.</li> <li>Use the generated agent lists (<code>plant_list</code>, <code>pol_list</code>) as inputs     for the modelling functions in <code>modelling.py</code>.</li> </ol> Notes <ul> <li>These classes encapsulate the basic agent properties and their environment,   but do not define network interactions or simulation dynamics (handled in <code>modelling.py</code>).</li> <li>Agent movement and interaction rules can be extended by adding methods to <code>Agent_Pol</code>   or creating new environment classes.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from netbayesabm.classes import Environment_plant, Environment_pol\n&gt;&gt;&gt; df_plants = pd.DataFrame({\n...     \"Plant_id\": [1, 2],\n...     \"Plant_sp\": [\"rose\", \"daisy\"],\n...     \"X\": [0.0, 1.0],\n...     \"Y\": [0.0, 1.0],\n...     \"Plant_sp_complete\": [\"Rosa sp.\", \"Bellis perennis\"]\n... })\n&gt;&gt;&gt; env_plants = Environment_plant(df_plants)\n&gt;&gt;&gt; len(env_plants.plant_list)\n2\n</code></pre>"},{"location":"api/#netbayesabm.classes.Agent_Plant","title":"<code>Agent_Plant</code>  <code>dataclass</code>","text":"<p>Plant agent in the pollination network.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Unique identifier of the plant.</p> required <code>sp</code> <code>str</code> <p>Short species label.</p> required <code>x</code> <code>float</code> <p>X-coordinate of the plant in the environment.</p> required <code>y</code> <code>float</code> <p>Y-coordinate of the plant in the environment.</p> required <code>sp_complete</code> <code>str</code> <p>Full species name.</p> required Source code in <code>netbayesabm/classes.py</code> <pre><code>@dataclass\nclass Agent_Plant:\n    \"\"\"\n    Plant agent in the pollination network.\n\n    Parameters\n    ----------\n    id : int\n        Unique identifier of the plant.\n    sp : str\n        Short species label.\n    x : float\n        X-coordinate of the plant in the environment.\n    y : float\n        Y-coordinate of the plant in the environment.\n    sp_complete : str\n        Full species name.\n    \"\"\"\n    id: int\n    sp: str\n    x: float\n    y: float\n    sp_complete: str\n</code></pre>"},{"location":"api/#netbayesabm.classes.Agent_Pol","title":"<code>Agent_Pol</code>  <code>dataclass</code>","text":"<p>Pollinator agent in the pollination network.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Unique identifier of the pollinator.</p> required <code>specie</code> <code>str</code> <p>Species label of the pollinator.</p> required <code>x</code> <code>float</code> <p>X-coordinate of the pollinator in the environment.</p> required <code>y</code> <code>float</code> <p>Y-coordinate of the pollinator in the environment.</p> required <code>radioAccion</code> <code>float</code> <p>Action radius of the pollinator, defining its interaction range.</p> required Source code in <code>netbayesabm/classes.py</code> <pre><code>@dataclass\nclass Agent_Pol:\n    \"\"\"\n    Pollinator agent in the pollination network.\n\n    Parameters\n    ----------\n    id : int\n        Unique identifier of the pollinator.\n    specie : str\n        Species label of the pollinator.\n    x : float\n        X-coordinate of the pollinator in the environment.\n    y : float\n        Y-coordinate of the pollinator in the environment.\n    radioAccion : float\n        Action radius of the pollinator, defining its interaction range.\n    \"\"\"\n    id: int\n    specie: str\n    x: float\n    y: float\n    radioAccion: float\n\n    def random_xy_pol(self, xmin: float, xmax: float, ymin: float, ymax: float) -&gt; None:\n        \"\"\"\n        Move the pollinator agent using a Brownian-like movement.\n\n        The new position is wrapped within the spatial boundaries of the environment.\n\n        Parameters\n        ----------\n        xmin, xmax : float\n            Minimum and maximum x-coordinates of the environment.\n        ymin, ymax : float\n            Minimum and maximum y-coordinates of the environment.\n\n        Returns\n        -------\n        None\n            The pollinator's `x` and `y` attributes are updated in place.\n\n        Examples\n        --------\n        &gt;&gt;&gt; p = Agent_Pol(id=1, specie=\"bee\", x=5.0, y=5.0, radioAccion=1.0)\n        &gt;&gt;&gt; p.random_xy_pol(0, 10, 0, 10)\n        &gt;&gt;&gt; 0 &lt;= p.x &lt;= 10 and 0 &lt;= p.y &lt;= 10\n        True\n        \"\"\"\n        m = self.radioAccion\n        self.x = (self.x + np.random.uniform(-m, m) - xmin) % (xmax - xmin) + xmin\n        self.y = (self.y + np.random.uniform(-m, m) - ymin) % (ymax - ymin) + ymin\n</code></pre>"},{"location":"api/#netbayesabm.classes.Agent_Pol.random_xy_pol","title":"<code>random_xy_pol(xmin, xmax, ymin, ymax)</code>","text":"<p>Move the pollinator agent using a Brownian-like movement.</p> <p>The new position is wrapped within the spatial boundaries of the environment.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>Minimum and maximum x-coordinates of the environment.</p> required <code>xmax</code> <code>float</code> <p>Minimum and maximum x-coordinates of the environment.</p> required <code>ymin</code> <code>float</code> <p>Minimum and maximum y-coordinates of the environment.</p> required <code>ymax</code> <code>float</code> <p>Minimum and maximum y-coordinates of the environment.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The pollinator's <code>x</code> and <code>y</code> attributes are updated in place.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; p = Agent_Pol(id=1, specie=\"bee\", x=5.0, y=5.0, radioAccion=1.0)\n&gt;&gt;&gt; p.random_xy_pol(0, 10, 0, 10)\n&gt;&gt;&gt; 0 &lt;= p.x &lt;= 10 and 0 &lt;= p.y &lt;= 10\nTrue\n</code></pre> Source code in <code>netbayesabm/classes.py</code> <pre><code>def random_xy_pol(self, xmin: float, xmax: float, ymin: float, ymax: float) -&gt; None:\n    \"\"\"\n    Move the pollinator agent using a Brownian-like movement.\n\n    The new position is wrapped within the spatial boundaries of the environment.\n\n    Parameters\n    ----------\n    xmin, xmax : float\n        Minimum and maximum x-coordinates of the environment.\n    ymin, ymax : float\n        Minimum and maximum y-coordinates of the environment.\n\n    Returns\n    -------\n    None\n        The pollinator's `x` and `y` attributes are updated in place.\n\n    Examples\n    --------\n    &gt;&gt;&gt; p = Agent_Pol(id=1, specie=\"bee\", x=5.0, y=5.0, radioAccion=1.0)\n    &gt;&gt;&gt; p.random_xy_pol(0, 10, 0, 10)\n    &gt;&gt;&gt; 0 &lt;= p.x &lt;= 10 and 0 &lt;= p.y &lt;= 10\n    True\n    \"\"\"\n    m = self.radioAccion\n    self.x = (self.x + np.random.uniform(-m, m) - xmin) % (xmax - xmin) + xmin\n    self.y = (self.y + np.random.uniform(-m, m) - ymin) % (ymax - ymin) + ymin\n</code></pre>"},{"location":"api/#netbayesabm.classes.Environment_plant","title":"<code>Environment_plant</code>","text":"<p>Environment for plant agents.</p> <p>Builds a list of <code>Agent_Plant</code> objects from a pandas DataFrame, assigning spatial positions either as provided, randomly, or in a regular grid.</p> <p>Parameters:</p> Name Type Description Default <code>df_plantPM</code> <code>DataFrame</code> <p>DataFrame containing plant information. Must include the following columns: - <code>Plant_id</code> : int, unique identifier of the plant - <code>Plant_sp</code> : str, short species name - <code>X</code> : float, x-coordinate (if no random/regular positioning) - <code>Y</code> : float, y-coordinate (if no random/regular positioning) - <code>Plant_sp_complete</code> : str, full species name</p> required <code>random_position</code> <code>bool</code> <p>If True, assign random coordinates uniformly within the given boundaries.</p> <code>False</code> <code>regular_position</code> <code>bool</code> <p>If True, assign coordinates on a regular grid within the given boundaries.</p> <code>False</code> <code>xmin</code> <code>float</code> <p>Spatial boundaries. Required if <code>random_position=True</code> or <code>regular_position=True</code>.</p> <code>None</code> <code>xmax</code> <code>float</code> <p>Spatial boundaries. Required if <code>random_position=True</code> or <code>regular_position=True</code>.</p> <code>None</code> <code>ymin</code> <code>float</code> <p>Spatial boundaries. Required if <code>random_position=True</code> or <code>regular_position=True</code>.</p> <code>None</code> <code>ymax</code> <code>float</code> <p>Spatial boundaries. Required if <code>random_position=True</code> or <code>regular_position=True</code>.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>plant_list</code> <code>list of Agent_Plant</code> <p>List of plant agents created from the DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"Plant_id\": [1, 2, 3, 4],\n...     \"Plant_sp\": [\"rose\", \"daisy\", \"tulip\", \"sunflower\"],\n...     \"X\": [0, 0, 0, 0],\n...     \"Y\": [0, 0, 0, 0],\n...     \"Plant_sp_complete\": [\"Rosa sp.\", \"Bellis perennis\", \"Tulipa sp.\", \"Helianthus annuus\"]\n... })\n&gt;&gt;&gt; env = Environment_plant(df, regular_position=True, xmin=0, xmax=10, ymin=0, ymax=10)\n&gt;&gt;&gt; all(isinstance(p.x, float) and isinstance(p.y, float) for p in env.plant_list)\nTrue\n</code></pre> Source code in <code>netbayesabm/classes.py</code> <pre><code>class Environment_plant:\n    \"\"\"\n    Environment for plant agents.\n\n    Builds a list of `Agent_Plant` objects from a pandas DataFrame, assigning\n    spatial positions either as provided, randomly, or in a regular grid.\n\n    Parameters\n    ----------\n    df_plantPM : pandas.DataFrame\n        DataFrame containing plant information. Must include the following columns:\n        - ``Plant_id`` : int, unique identifier of the plant\n        - ``Plant_sp`` : str, short species name\n        - ``X`` : float, x-coordinate (if no random/regular positioning)\n        - ``Y`` : float, y-coordinate (if no random/regular positioning)\n        - ``Plant_sp_complete`` : str, full species name\n    random_position : bool, default=False\n        If True, assign random coordinates uniformly within the given boundaries.\n    regular_position : bool, default=False\n        If True, assign coordinates on a regular grid within the given boundaries.\n    xmin, xmax, ymin, ymax : float, optional\n        Spatial boundaries. Required if `random_position=True` or `regular_position=True`.\n\n    Attributes\n    ----------\n    plant_list : list of Agent_Plant\n        List of plant agents created from the DataFrame.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; df = pd.DataFrame({\n    ...     \"Plant_id\": [1, 2, 3, 4],\n    ...     \"Plant_sp\": [\"rose\", \"daisy\", \"tulip\", \"sunflower\"],\n    ...     \"X\": [0, 0, 0, 0],\n    ...     \"Y\": [0, 0, 0, 0],\n    ...     \"Plant_sp_complete\": [\"Rosa sp.\", \"Bellis perennis\", \"Tulipa sp.\", \"Helianthus annuus\"]\n    ... })\n    &gt;&gt;&gt; env = Environment_plant(df, regular_position=True, xmin=0, xmax=10, ymin=0, ymax=10)\n    &gt;&gt;&gt; all(isinstance(p.x, float) and isinstance(p.y, float) for p in env.plant_list)\n    True\n    \"\"\"\n\n    def __init__(\n        self,\n        df_plantPM,\n        random_position: bool = False,\n        regular_position: bool = False,\n        xmin: float | None = None,\n        xmax: float | None = None,\n        ymin: float | None = None,\n        ymax: float | None = None,\n    ):\n        if random_position or regular_position:\n            if None in [xmin, xmax, ymin, ymax]:\n                raise ValueError(\"xmin, xmax, ymin, ymax must be provided for random or regular positioning\")\n\n        if random_position:\n            # Random coordinates\n            df_plantPM[\"X\"] = np.random.uniform(xmin, xmax, len(df_plantPM))\n            df_plantPM[\"Y\"] = np.random.uniform(ymin, ymax, len(df_plantPM))\n\n        elif regular_position:\n            # Regular grid coordinates\n            num_plants = len(df_plantPM)\n            num_rows = int(np.ceil(np.sqrt(num_plants)))\n            num_cols = int(np.ceil(num_plants / num_rows))\n\n            x_vals = np.linspace(xmin, xmax, num_cols)\n            y_vals = np.linspace(ymin, ymax, num_rows)\n            xy_combinations = [(x, y) for y in y_vals for x in x_vals]\n\n            xy_combinations = xy_combinations[:num_plants]\n            for i in range(num_plants):\n                df_plantPM.iloc[i, df_plantPM.columns.get_loc(\"X\")] = xy_combinations[i][0]\n                df_plantPM.iloc[i, df_plantPM.columns.get_loc(\"Y\")] = xy_combinations[i][1]\n\n        self.plant_list = df_plantPM.apply(\n            lambda row: Agent_Plant(\n                id=row.Plant_id,\n                sp=row.Plant_sp,\n                x=row.X,\n                y=row.Y,\n                sp_complete=row.Plant_sp_complete,\n            ),\n            axis=1,\n        ).tolist()\n</code></pre>"},{"location":"api/#netbayesabm.classes.Environment_pol","title":"<code>Environment_pol</code>","text":"<p>Environment for pollinator agents.</p> <p>Builds a list of <code>Agent_Pol</code> objects from a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df_polPM</code> <code>DataFrame</code> <p>DataFrame containing pollinator information. Must include the following columns: - <code>Pol_id</code> : int, unique identifier of the pollinator - <code>Specie</code> : str, species name - <code>x</code> : float, x-coordinate - <code>y</code> : float, y-coordinate - <code>Radius</code> : float, action radius of the pollinator</p> required <p>Attributes:</p> Name Type Description <code>pol_list</code> <code>list of Agent_Pol</code> <p>List of pollinator agents created from the DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"Pol_id\": [1, 2],\n...     \"Specie\": [\"bee\", \"fly\"],\n...     \"x\": [1.0, 2.0],\n...     \"y\": [3.0, 4.0],\n...     \"Radius\": [1.5, 2.0]\n... })\n&gt;&gt;&gt; env = Environment_pol(df)\n&gt;&gt;&gt; len(env.pol_list)\n2\n</code></pre> Source code in <code>netbayesabm/classes.py</code> <pre><code>class Environment_pol:\n    \"\"\"\n    Environment for pollinator agents.\n\n    Builds a list of `Agent_Pol` objects from a pandas DataFrame.\n\n    Parameters\n    ----------\n    df_polPM : pandas.DataFrame\n        DataFrame containing pollinator information. Must include the following columns:\n        - ``Pol_id`` : int, unique identifier of the pollinator\n        - ``Specie`` : str, species name\n        - ``x`` : float, x-coordinate\n        - ``y`` : float, y-coordinate\n        - ``Radius`` : float, action radius of the pollinator\n\n    Attributes\n    ----------\n    pol_list : list of Agent_Pol\n        List of pollinator agents created from the DataFrame.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; df = pd.DataFrame({\n    ...     \"Pol_id\": [1, 2],\n    ...     \"Specie\": [\"bee\", \"fly\"],\n    ...     \"x\": [1.0, 2.0],\n    ...     \"y\": [3.0, 4.0],\n    ...     \"Radius\": [1.5, 2.0]\n    ... })\n    &gt;&gt;&gt; env = Environment_pol(df)\n    &gt;&gt;&gt; len(env.pol_list)\n    2\n    \"\"\"\n\n    def __init__(self, df_polPM):\n        self.pol_list = df_polPM.apply(\n            lambda row: Agent_Pol(\n                id=row.Pol_id,\n                specie=row.Specie,\n                x=row.x,\n                y=row.y,\n                radioAccion=row.Radius,\n            ),\n            axis=1,\n        ).tolist()\n</code></pre>"},{"location":"api/#modelling","title":"Modelling","text":""},{"location":"api/#netbayesabm.modelling--netbayesabm-modelling-module","title":"NetBayesABM - Modelling Module","text":"<p>This module provides the core functions to build and simulate agent-based models (ABM) of plant\u2013pollinator networks.</p> <p>The functions cover: - Initialization of agents (plants and pollinators) with random,   empirical, or regular spatial distributions. - Construction of bipartite plant\u2013pollinator networks. - Evolution rules for agent movement and interaction. - Updating of network edges and weights over time.</p> Typical workflow <ol> <li>Generate agents using initialization functions (e.g., <code>initial_pollinators_random</code>).</li> <li>Create a bipartite network with <code>initial_network</code>.</li> <li>Simulate dynamics with update functions (<code>update</code>, <code>update_totalinks</code>).</li> <li>Analyze resulting structures with network metrics or export to data frames.</li> </ol> Notes <ul> <li>This module relies on classes defined in <code>classes.py</code> (e.g., <code>Agent_Plant</code>, <code>Agent_Pol</code>)   for representing agents.</li> <li>The functions are designed to be flexible: randomization, classification of species,   and movement dynamics can be adapted depending on the scenario.</li> <li>Networks are handled using NetworkX.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netbayesabm import modelling as mdl\n&gt;&gt;&gt; generalists, poll_df = mdl.initial_pollinators_random(dist, 2, 50, 0, 10, 0, 10)\n&gt;&gt;&gt; B = mdl.initial_network(poll_df[\"Specie\"].unique(), plant_ids)\n&gt;&gt;&gt; mdl.update_totalinks(100, env_pol, env_plant, B, 0, 10, 0, 10)\n</code></pre>"},{"location":"api/#netbayesabm.modelling.degree_dist","title":"<code>degree_dist(df)</code>","text":"<p>Compute the degree distribution of plants and pollinators in a bipartite adjacency matrix.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Bipartite adjacency matrix (rows = plants, columns = pollinators). Values should be numeric (0/1 or weights).</p> required <p>Returns:</p> Name Type Description <code>pol_degree</code> <code>Series</code> <p>Degree distribution of pollinators (sum over rows).</p> <code>plant_degree</code> <code>Series</code> <p>Degree distribution of plants (sum over columns).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; M = pd.DataFrame([[1, 0], [1, 1]], index=[\"plant1\", \"plant2\"], columns=[\"bee\", \"fly\"])\n&gt;&gt;&gt; pol_degree, plant_degree = degree_dist(M)\n&gt;&gt;&gt; pol_degree.to_dict()\n{'bee': 2, 'fly': 1}\n&gt;&gt;&gt; plant_degree.to_dict()\n{'plant1': 1, 'plant2': 2}\n</code></pre> Source code in <code>netbayesabm/modelling.py</code> <pre><code>def degree_dist(df: pd.DataFrame) -&gt; tuple[pd.Series, pd.Series]:\n    \"\"\"\n    Compute the degree distribution of plants and pollinators\n    in a bipartite adjacency matrix.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        Bipartite adjacency matrix (rows = plants, columns = pollinators).\n        Values should be numeric (0/1 or weights).\n\n    Returns\n    -------\n    pol_degree : pandas.Series\n        Degree distribution of pollinators (sum over rows).\n    plant_degree : pandas.Series\n        Degree distribution of plants (sum over columns).\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; M = pd.DataFrame([[1, 0], [1, 1]], index=[\"plant1\", \"plant2\"], columns=[\"bee\", \"fly\"])\n    &gt;&gt;&gt; pol_degree, plant_degree = degree_dist(M)\n    &gt;&gt;&gt; pol_degree.to_dict()\n    {'bee': 2, 'fly': 1}\n    &gt;&gt;&gt; plant_degree.to_dict()\n    {'plant1': 1, 'plant2': 2}\n    \"\"\"\n    plant_degree = df.astype(bool).sum(axis=1)\n    pol_degree = df.astype(bool).sum(axis=0)\n    return pol_degree, plant_degree\n</code></pre>"},{"location":"api/#netbayesabm.modelling.initial_network","title":"<code>initial_network(pollinators, plants)</code>","text":"<p>Create the initial bipartite directed network of pollinators and plants.</p> <p>The initial graph is a complete directed bipartite graph with all edges from pollinators to plants, initialized with weight = 0.</p> <p>Parameters:</p> Name Type Description Default <code>pollinators</code> <code>list of str</code> <p>Labels (IDs) of pollinator nodes.</p> required <code>plants</code> <code>list of str</code> <p>Labels (IDs) of plant nodes.</p> required <p>Returns:</p> Type Description <code>DiGraph</code> <p>Directed bipartite graph with: - Nodes in two partitions (pollinators, plants). - Edges from pollinators to plants with weight = 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pollinators = [\"bee\", \"fly\"]\n&gt;&gt;&gt; plants = [\"rose\", \"daisy\"]\n&gt;&gt;&gt; G = initial_network(pollinators, plants)\n&gt;&gt;&gt; G.number_of_edges()\n4\n</code></pre> Source code in <code>netbayesabm/modelling.py</code> <pre><code>def initial_network(\n    pollinators: list[str],\n    plants: list[str]\n) -&gt; nx.DiGraph:\n    \"\"\"\n    Create the initial bipartite directed network of pollinators and plants.\n\n    The initial graph is a complete directed bipartite graph with all edges\n    from pollinators to plants, initialized with weight = 0.\n\n    Parameters\n    ----------\n    pollinators : list of str\n        Labels (IDs) of pollinator nodes.\n    plants : list of str\n        Labels (IDs) of plant nodes.\n\n    Returns\n    -------\n    networkx.DiGraph\n        Directed bipartite graph with:\n        - Nodes in two partitions (pollinators, plants).\n        - Edges from pollinators to plants with weight = 0.\n\n    Examples\n    --------\n    &gt;&gt;&gt; pollinators = [\"bee\", \"fly\"]\n    &gt;&gt;&gt; plants = [\"rose\", \"daisy\"]\n    &gt;&gt;&gt; G = initial_network(pollinators, plants)\n    &gt;&gt;&gt; G.number_of_edges()\n    4\n    \"\"\"\n    B = nx.DiGraph()\n    B.add_nodes_from(pollinators, bipartite=0)\n    B.add_nodes_from(plants, bipartite=1)\n    B.add_weighted_edges_from((u, v, 0) for u in pollinators for v in plants)\n    return B\n</code></pre>"},{"location":"api/#netbayesabm.modelling.initial_pollinators","title":"<code>initial_pollinators(dist_pol, n_pols, xmin, xmax, ymin, ymax)</code>","text":"<p>Generate the initial distribution of pollinators (always classified into generalists and specialists).</p> <p>Parameters:</p> Name Type Description Default <code>dist_pol</code> <code>Series</code> <p>Abundance distribution of pollinator species. Index must correspond to species labels.</p> required <code>n_spe_pol</code> <code>int</code> <p>Number of pollinator species.</p> required <code>n_pols</code> <code>int</code> <p>Total number of pollinator individuals.</p> required <code>xmin</code> <code>float</code> <p>Spatial boundaries for generating coordinates.</p> required <code>xmax</code> <code>float</code> <p>Spatial boundaries for generating coordinates.</p> required <code>ymin</code> <code>float</code> <p>Spatial boundaries for generating coordinates.</p> required <code>ymax</code> <code>float</code> <p>Spatial boundaries for generating coordinates.</p> required <p>Returns:</p> Name Type Description <code>generalists</code> <code>list of str</code> <p>List of species classified as generalists.</p> <code>df_final</code> <code>DataFrame</code> <p>DataFrame with pollinator attributes: - <code>Pol_id</code> : unique ID of each pollinator - <code>Specie</code> : species label - <code>x, y</code> : spatial coordinates - <code>Radius</code> : interaction radius - <code>Tipo</code> : category (Generalist or Specialist)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dist = pd.Series([0.3, 0.7], index=[\"bee\", \"butterfly\"])\n&gt;&gt;&gt; generalists, df = initial_pollinators(dist, 2, 30, 0, 5, 0, 5)\n&gt;&gt;&gt; len(df)\n30\n</code></pre> Source code in <code>netbayesabm/modelling.py</code> <pre><code>def initial_pollinators(\n    dist_pol: pd.Series,\n    n_pols: int,\n    xmin: float,\n    xmax: float,\n    ymin: float,\n    ymax: float\n) -&gt; tuple[list[str], pd.DataFrame]:\n    \"\"\"\n    Generate the initial distribution of pollinators (always classified into generalists\n    and specialists).\n\n    Parameters\n    ----------\n    dist_pol : pandas.Series\n        Abundance distribution of pollinator species. Index must correspond to species labels.\n    n_spe_pol : int\n        Number of pollinator species.\n    n_pols : int\n        Total number of pollinator individuals.\n    xmin, xmax, ymin, ymax : float\n        Spatial boundaries for generating coordinates.\n\n    Returns\n    -------\n    generalists : list of str\n        List of species classified as generalists.\n    df_final : pandas.DataFrame\n        DataFrame with pollinator attributes:\n        - ``Pol_id`` : unique ID of each pollinator\n        - ``Specie`` : species label\n        - ``x, y`` : spatial coordinates\n        - ``Radius`` : interaction radius\n        - ``Tipo`` : category (Generalist or Specialist)\n\n    Examples\n    --------\n    &gt;&gt;&gt; dist = pd.Series([0.3, 0.7], index=[\"bee\", \"butterfly\"])\n    &gt;&gt;&gt; generalists, df = initial_pollinators(dist, 2, 30, 0, 5, 0, 5)\n    &gt;&gt;&gt; len(df)\n    30\n    \"\"\"\n    abundances = dist_pol.values.reshape(-1, 1)\n    c1 = np.mean(dist_pol.values[:-2])\n    c2 = np.mean(dist_pol.values[2:])\n    initial_centroids = np.array([[c1], [c2]])\n\n    kmeans = KMeans(n_clusters=2, init=initial_centroids, random_state=42)\n    kmeans.fit(abundances)\n\n    labels = kmeans.labels_\n    df_intermediate = pd.DataFrame(\n        {\"Abundance\": abundances.flatten(), \"Label\": labels}, index=dist_pol.index\n    )\n    df_intermediate[\"Label\"] = df_intermediate[\"Label\"].map(\n        {0: \"Specialist\", 1: \"Generalist\"}\n    )\n    generalists = df_intermediate.loc[\n        df_intermediate[\"Label\"] == \"Generalist\"\n    ].index.tolist()\n\n    pollinators = np.random.choice(dist_pol.index, n_pols, p=dist_pol)\n\n    ids = np.arange(1000, 1000 + n_pols)\n    xs = np.round(xmin + np.random.rand(n_pols) * (xmax - xmin), 3)\n    ys = np.round(ymin + np.random.rand(n_pols) * (ymax - ymin), 3)\n    radii = np.where(np.isin(pollinators, generalists), 15, 5)\n\n    df_final = pd.DataFrame(\n        {\"Pol_id\": ids, \"Specie\": pollinators, \"x\": xs, \"y\": ys, \"Radius\": radii},\n        index=ids,\n    )\n    df_final[\"Tipo\"] = np.where(\n        df_final[\"Specie\"].isin(generalists), \"Generalist\", \"Specialist\"\n    )\n\n    return generalists, df_final\n</code></pre>"},{"location":"api/#netbayesabm.modelling.initial_pollinators_random","title":"<code>initial_pollinators_random(dist_pol, n_pols, xmin, xmax, ymin, ymax, classify=True, random_distribution=False)</code>","text":"<p>Generate the initial distribution of pollinators with customizable options.</p> <p>Parameters:</p> Name Type Description Default <code>dist_pol</code> <code>Series</code> <p>Abundance distribution of pollinator species. Index must correspond to species labels.</p> required <code>n_pols</code> <code>int</code> <p>Total number of pollinator individuals.</p> required <code>xmin</code> <code>float</code> <p>Spatial boundaries for generating coordinates.</p> required <code>xmax</code> <code>float</code> <p>Spatial boundaries for generating coordinates.</p> required <code>ymin</code> <code>float</code> <p>Spatial boundaries for generating coordinates.</p> required <code>ymax</code> <code>float</code> <p>Spatial boundaries for generating coordinates.</p> required <code>classify</code> <code>bool</code> <p>If True, classify pollinator species into generalists and specialists using K-means.</p> <code>True</code> <code>random_distribution</code> <code>bool</code> <p>If True, ignore <code>dist_pol</code> and assign individuals randomly using a Dirichlet distribution.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>generalists</code> <code>list of str</code> <p>List of species classified as generalists (empty if <code>classify=False</code>).</p> <code>df_final</code> <code>DataFrame</code> <p>DataFrame with pollinator attributes: - <code>Pol_id</code> : unique ID of each pollinator - <code>Specie</code> : species label - <code>x, y</code> : spatial coordinates - <code>Radius</code> : interaction radius (larger for generalists) - <code>Tipo</code> : category (Generalist, Specialist, or Unclassified)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dist = pd.Series([0.4, 0.6], index=[\"bee\", \"fly\"])\n&gt;&gt;&gt; generalists, df = initial_pollinators_random(dist, 2, 50, 0, 10, 0, 10)\n&gt;&gt;&gt; df.head()\n   Pol_id Specie     x     y  Radius         Tipo\n0    1000    bee  2.33  8.12      15  Generalista\n</code></pre> Source code in <code>netbayesabm/modelling.py</code> <pre><code>def initial_pollinators_random(\n    dist_pol: pd.Series,\n    n_pols: int,\n    xmin: float,\n    xmax: float,\n    ymin: float,\n    ymax: float,\n    classify: bool = True,\n    random_distribution: bool = False\n) -&gt; tuple[list[str], pd.DataFrame]:\n    \"\"\"\n    Generate the initial distribution of pollinators with customizable options.\n\n    Parameters\n    ----------\n    dist_pol : pandas.Series\n        Abundance distribution of pollinator species. Index must correspond to species labels.\n    n_pols : int\n        Total number of pollinator individuals.\n    xmin, xmax, ymin, ymax : float\n        Spatial boundaries for generating coordinates.\n    classify : bool, default=True\n        If True, classify pollinator species into generalists and specialists using K-means.\n    random_distribution : bool, default=False\n        If True, ignore `dist_pol` and assign individuals randomly using a Dirichlet distribution.\n\n    Returns\n    -------\n    generalists : list of str\n        List of species classified as generalists (empty if `classify=False`).\n    df_final : pandas.DataFrame\n        DataFrame with pollinator attributes:\n        - ``Pol_id`` : unique ID of each pollinator\n        - ``Specie`` : species label\n        - ``x, y`` : spatial coordinates\n        - ``Radius`` : interaction radius (larger for generalists)\n        - ``Tipo`` : category (Generalist, Specialist, or Unclassified)\n\n    Examples\n    --------\n    &gt;&gt;&gt; dist = pd.Series([0.4, 0.6], index=[\"bee\", \"fly\"])\n    &gt;&gt;&gt; generalists, df = initial_pollinators_random(dist, 2, 50, 0, 10, 0, 10)\n    &gt;&gt;&gt; df.head()\n       Pol_id Specie     x     y  Radius         Tipo\n    0    1000    bee  2.33  8.12      15  Generalista\n    \"\"\"\n    generalists = []\n\n    if classify:\n        # Cluster species into generalists and specialists\n        abundances = dist_pol.values.reshape(-1, 1)\n        c1 = np.mean(dist_pol.values[:-2])\n        c2 = np.mean(dist_pol.values[2:])\n        initial_centroids = np.array([[c1], [c2]])\n\n        kmeans = KMeans(n_clusters=2, init=initial_centroids, random_state=42)\n        kmeans.fit(abundances)\n\n        labels = kmeans.labels_\n        df_intermediate = pd.DataFrame(\n            {\"Abundance\": abundances.flatten(), \"Label\": labels},\n            index=dist_pol.index\n        )\n        df_intermediate[\"Label\"] = df_intermediate[\"Label\"].map(\n            {0: \"Specialist\", 1: \"Generalist\"}\n        )\n        generalists = df_intermediate.loc[\n            df_intermediate[\"Label\"] == \"Generalist\"\n        ].index.tolist()\n\n    # Probability distribution\n    if random_distribution:\n        probabilities = np.random.dirichlet(np.ones(len(dist_pol)), size=1).flatten()\n    else:\n        probabilities = dist_pol\n\n    # Sample pollinator species\n    pollinators = np.random.choice(dist_pol.index, n_pols, p=probabilities)\n\n    # Attributes\n    ids = np.arange(1000, 1000 + n_pols)\n    xs = np.round(xmin + np.random.rand(n_pols) * (xmax - xmin), 3)\n    ys = np.round(ymin + np.random.rand(n_pols) * (ymax - ymin), 3)\n\n    if classify:\n        radii = np.where(np.isin(pollinators, generalists), 15, 5)\n    else:\n        radii = np.random.gamma(10, 2, size=n_pols)\n\n    df_final = pd.DataFrame(\n        {\"Pol_id\": ids, \"Specie\": pollinators, \"x\": xs, \"y\": ys, \"Radius\": radii},\n        index=ids,\n    )\n\n    if classify:\n        df_final[\"Tipo\"] = np.where(\n            df_final[\"Specie\"].isin(generalists), \"Generalist\", \"Specialist\"\n        )\n    else:\n        df_final[\"Tipo\"] = \"Unclassified\"\n\n    return generalists, df_final\n</code></pre>"},{"location":"api/#netbayesabm.modelling.plant_pol","title":"<code>plant_pol(NewAgent, env)</code>","text":"<p>Find all plants within the action radius of a pollinator agent.</p> <p>Parameters:</p> Name Type Description Default <code>NewAgent</code> <code>object</code> <p>Pollinator agent with attributes: - <code>x</code> (float) : x-coordinate - <code>y</code> (float) : y-coordinate - <code>radioAccion</code> (float) : action radius</p> required <code>env</code> <code>object</code> <p>Environment object with attribute: - <code>plant_list</code> (list) : list of plant agents, each with <code>x</code> and <code>y</code>.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of plant agents located within the action radius of <code>NewAgent</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; neighbors = plant_pol(pollinator, environment)\n&gt;&gt;&gt; len(neighbors)\n3\n</code></pre> Source code in <code>netbayesabm/modelling.py</code> <pre><code>def plant_pol(NewAgent, env) -&gt; list:\n    \"\"\"\n    Find all plants within the action radius of a pollinator agent.\n\n    Parameters\n    ----------\n    NewAgent : object\n        Pollinator agent with attributes:\n        - ``x`` (float) : x-coordinate\n        - ``y`` (float) : y-coordinate\n        - ``radioAccion`` (float) : action radius\n    env : object\n        Environment object with attribute:\n        - ``plant_list`` (list) : list of plant agents, each with ``x`` and ``y``.\n\n    Returns\n    -------\n    list\n        List of plant agents located within the action radius of `NewAgent`.\n\n    Examples\n    --------\n    &gt;&gt;&gt; neighbors = plant_pol(pollinator, environment)\n    &gt;&gt;&gt; len(neighbors)\n    3\n    \"\"\"\n    x, y, radius = NewAgent.x, NewAgent.y, NewAgent.radioAccion\n    neighbors = [\n        nb for nb in env.plant_list\n        if (x - nb.x) ** 2 + (y - nb.y) ** 2 &lt; radius ** 2\n    ]\n    return neighbors\n</code></pre>"},{"location":"api/#netbayesabm.modelling.remove_zero","title":"<code>remove_zero(B)</code>","text":"<p>Remove edges with zero weight from a bipartite network.</p> <p>Parameters:</p> Name Type Description Default <code>B</code> <code>DiGraph</code> <p>Directed bipartite graph with weighted edges.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The graph is modified in place.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; G = initial_network([\"bee\"], [\"rose\"])\n&gt;&gt;&gt; remove_zero(G)\n&gt;&gt;&gt; G.number_of_edges()\n0\n</code></pre> Source code in <code>netbayesabm/modelling.py</code> <pre><code>def remove_zero(B: nx.DiGraph) -&gt; None:\n    \"\"\"\n    Remove edges with zero weight from a bipartite network.\n\n    Parameters\n    ----------\n    B : networkx.DiGraph\n        Directed bipartite graph with weighted edges.\n\n    Returns\n    -------\n    None\n        The graph is modified in place.\n\n    Examples\n    --------\n    &gt;&gt;&gt; G = initial_network([\"bee\"], [\"rose\"])\n    &gt;&gt;&gt; remove_zero(G)\n    &gt;&gt;&gt; G.number_of_edges()\n    0\n    \"\"\"\n    edge_list = [(u, v) for (u, v, w) in B.edges(data=True) if w[\"weight\"] == 0]\n    B.remove_edges_from(edge_list)\n</code></pre>"},{"location":"api/#netbayesabm.modelling.update","title":"<code>update(envpol, evenp, B, xmin, xmax, ymin, ymax)</code>","text":"<p>Perform a single update of the pollinator\u2013plant network.</p> <p>A random pollinator is selected, moved to a new position, and linked to the closest plant within its action radius. The corresponding edge weight in the bipartite graph is increased by 1.</p> <p>Parameters:</p> Name Type Description Default <code>envpol</code> <code>object</code> <p>Environment object with attribute <code>pol_list</code> (list of pollinator agents).</p> required <code>evenp</code> <code>object</code> <p>Environment object with attribute <code>plant_list</code> (list of plant agents).</p> required <code>B</code> <code>DiGraph</code> <p>Bipartite directed graph of pollinators and plants, with weighted edges.</p> required <code>xmin</code> <code>float</code> <p>Spatial boundaries for repositioning pollinators.</p> required <code>xmax</code> <code>float</code> <p>Spatial boundaries for repositioning pollinators.</p> required <code>ymin</code> <code>float</code> <p>Spatial boundaries for repositioning pollinators.</p> required <code>ymax</code> <code>float</code> <p>Spatial boundaries for repositioning pollinators.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The graph <code>B</code> is updated in place.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; update(envpol, envplants, G, 0, 10, 0, 10)\n&gt;&gt;&gt; sum(nx.get_edge_attributes(G, \"weight\").values()) &gt; 0\nTrue\n</code></pre> Source code in <code>netbayesabm/modelling.py</code> <pre><code>def update(\n    envpol,\n    evenp,\n    B: nx.DiGraph,\n    xmin: float,\n    xmax: float,\n    ymin: float,\n    ymax: float\n) -&gt; None:\n    \"\"\"\n    Perform a single update of the pollinator\u2013plant network.\n\n    A random pollinator is selected, moved to a new position,\n    and linked to the closest plant within its action radius.\n    The corresponding edge weight in the bipartite graph is increased by 1.\n\n    Parameters\n    ----------\n    envpol : object\n        Environment object with attribute ``pol_list`` (list of pollinator agents).\n    evenp : object\n        Environment object with attribute ``plant_list`` (list of plant agents).\n    B : networkx.DiGraph\n        Bipartite directed graph of pollinators and plants, with weighted edges.\n    xmin, xmax, ymin, ymax : float\n        Spatial boundaries for repositioning pollinators.\n\n    Returns\n    -------\n    None\n        The graph `B` is updated in place.\n\n    Examples\n    --------\n    &gt;&gt;&gt; update(envpol, envplants, G, 0, 10, 0, 10)\n    &gt;&gt;&gt; sum(nx.get_edge_attributes(G, \"weight\").values()) &gt; 0\n    True\n    \"\"\"\n    indAgent = np.random.choice(len(envpol.pol_list))\n    NewAgent = envpol.pol_list[indAgent]\n\n    NewAgent.random_xy_pol(xmin, xmax, ymin, ymax)\n    neighbors = plant_pol(NewAgent, evenp)\n\n    if neighbors:\n        # compute distances to each neighbor\n        distances = [\n            (n, ((NewAgent.x - n.x) ** 2 + (NewAgent.y - n.y) ** 2) ** 0.5)\n            for n in neighbors\n        ]\n        # select the closest neighbor\n        selected_neigh = min(distances, key=lambda x: x[1])[0]\n        B[NewAgent.id][selected_neigh.id][\"weight\"] += 1\n</code></pre>"},{"location":"api/#netbayesabm.modelling.update_totalinks","title":"<code>update_totalinks(tlink, envpol, evenp, B, xmin, xmax, ymin, ymax)</code>","text":"<p>Update the bipartite network until the total number of links reaches <code>tlink</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tlink</code> <code>int</code> <p>Target number of links (sum of all edge weights).</p> required <code>envpol</code> <code>object</code> <p>Environment object with attribute <code>pol_list</code> (list of pollinator agents).</p> required <code>evenp</code> <code>object</code> <p>Environment object with attribute <code>plant_list</code> (list of plant agents).</p> required <code>B</code> <code>DiGraph</code> <p>Bipartite directed graph of pollinators and plants, with weighted edges.</p> required <code>xmin</code> <code>float</code> <p>Spatial boundaries for repositioning pollinators.</p> required <code>xmax</code> <code>float</code> <p>Spatial boundaries for repositioning pollinators.</p> required <code>ymin</code> <code>float</code> <p>Spatial boundaries for repositioning pollinators.</p> required <code>ymax</code> <code>float</code> <p>Spatial boundaries for repositioning pollinators.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The graph <code>B</code> is updated in place until the desired total number of links is reached.</p> Notes <p>This function has not been extensively tested.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; update_totalinks(100, envpol, envplants, G, 0, 10, 0, 10)\n&gt;&gt;&gt; sum(nx.get_edge_attributes(G, \"weight\").values())\n100\n</code></pre> Source code in <code>netbayesabm/modelling.py</code> <pre><code>def update_totalinks(\n    tlink: int,\n    envpol,\n    evenp,\n    B: nx.DiGraph,\n    xmin: float,\n    xmax: float,\n    ymin: float,\n    ymax: float\n) -&gt; None:\n    \"\"\"\n    Update the bipartite network until the total number of links reaches `tlink`.\n\n    Parameters\n    ----------\n    tlink : int\n        Target number of links (sum of all edge weights).\n    envpol : object\n        Environment object with attribute ``pol_list`` (list of pollinator agents).\n    evenp : object\n        Environment object with attribute ``plant_list`` (list of plant agents).\n    B : networkx.DiGraph\n        Bipartite directed graph of pollinators and plants, with weighted edges.\n    xmin, xmax, ymin, ymax : float\n        Spatial boundaries for repositioning pollinators.\n\n    Returns\n    -------\n    None\n        The graph `B` is updated in place until the desired total number of links is reached.\n\n    Notes\n    -----\n    This function has not been extensively tested.\n\n    Examples\n    --------\n    &gt;&gt;&gt; update_totalinks(100, envpol, envplants, G, 0, 10, 0, 10)\n    &gt;&gt;&gt; sum(nx.get_edge_attributes(G, \"weight\").values())\n    100\n    \"\"\"\n    total_links = sum(nx.get_edge_attributes(B, \"weight\").values())\n    while total_links &lt; tlink:\n        update(envpol, evenp, B, xmin, xmax, ymin, ymax)\n        total_links += 1\n</code></pre>"},{"location":"api/#data-analysis","title":"Data Analysis","text":""},{"location":"api/#netbayesabm.data_analysis--netbayesabm-data-analysis-module","title":"NetBayesABM - Data Analysis Module","text":"<p>This module provides helper functions for preprocessing and analyzing plant\u2013pollinator datasets prior to running the agent-based models (ABM).</p> <p>The functions include utilities for: - Extracting subsets of plants by plot and month. - Computing species frequencies and abundance distributions. - Determining spatial boundaries for simulation environments. - Preparing input data structures for agent initialization.</p> Typical workflow <ol> <li>Load empirical plant\u2013pollinator data into a pandas DataFrame.</li> <li>Use <code>freq_plant</code> to filter plants by plot and month and calculate species frequencies.</li> <li>Use <code>area_plot</code> to compute spatial boundaries for the environment.</li> <li>Pass the processed data to environment classes (<code>Environment_plant</code>, <code>Environment_pol</code>)    for ABM simulations.</li> </ol> Notes <ul> <li>All functions expect input data in the form of pandas DataFrames with specific columns   (e.g., <code>Plot</code>, <code>Month</code>, <code>Plant_sp_complete</code>, <code>X</code>, <code>Y</code>).</li> <li>The module does not perform simulations directly, but prepares data for the core modelling   functions in <code>modelling.py</code>.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netbayesabm import data_analysis as da\n&gt;&gt;&gt; df_sub, freq_table = da.freq_plant(\"A\", 5, df_plants)\n&gt;&gt;&gt; xmin, xmax, ymin, ymax = da.area_plot(df_sub)\n</code></pre>"},{"location":"api/#netbayesabm.data_analysis.area_plot","title":"<code>area_plot(df_plantPM, margin=2.0)</code>","text":"<p>Calculate the spatial boundaries (xmin, xmax, ymin, ymax) for a set of plants.</p> <p>The function computes the minimum and maximum x and y coordinates of plants in the DataFrame, and extends them by a given margin.</p> <p>Parameters:</p> Name Type Description Default <code>df_plantPM</code> <code>DataFrame</code> <p>DataFrame containing plant data. Must include columns: - <code>X</code> : float, x-coordinate - <code>Y</code> : float, y-coordinate</p> required <code>margin</code> <code>float</code> <p>Value added/subtracted to extend the boundaries beyond min/max.</p> <code>2.0</code> <p>Returns:</p> Name Type Description <code>xmin</code> <code>float</code> <p>Minimum x-coordinate minus margin.</p> <code>xmax</code> <code>float</code> <p>Maximum x-coordinate plus margin.</p> <code>ymin</code> <code>float</code> <p>Minimum y-coordinate minus margin.</p> <code>ymax</code> <code>float</code> <p>Maximum y-coordinate plus margin.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame({\"X\": [1.0, 2.5, 4.0], \"Y\": [0.5, 3.0, 2.0]})\n&gt;&gt;&gt; area_plot(df, margin=1.0)\n(0.0, 5.0, -0.5, 4.0)\n</code></pre> Source code in <code>netbayesabm/data_analysis.py</code> <pre><code>def area_plot(\n    df_plantPM: pd.DataFrame,\n    margin: float = 2.0\n) -&gt; tuple[float, float, float, float]:\n    \"\"\"\n    Calculate the spatial boundaries (xmin, xmax, ymin, ymax) for a set of plants.\n\n    The function computes the minimum and maximum x and y coordinates of plants\n    in the DataFrame, and extends them by a given margin.\n\n    Parameters\n    ----------\n    df_plantPM : pandas.DataFrame\n        DataFrame containing plant data. Must include columns:\n        - ``X`` : float, x-coordinate\n        - ``Y`` : float, y-coordinate\n    margin : float, default=2.0\n        Value added/subtracted to extend the boundaries beyond min/max.\n\n    Returns\n    -------\n    xmin : float\n        Minimum x-coordinate minus margin.\n    xmax : float\n        Maximum x-coordinate plus margin.\n    ymin : float\n        Minimum y-coordinate minus margin.\n    ymax : float\n        Maximum y-coordinate plus margin.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; df = pd.DataFrame({\"X\": [1.0, 2.5, 4.0], \"Y\": [0.5, 3.0, 2.0]})\n    &gt;&gt;&gt; area_plot(df, margin=1.0)\n    (0.0, 5.0, -0.5, 4.0)\n    \"\"\"\n    xmin = df_plantPM[\"X\"].min() - margin\n    xmax = df_plantPM[\"X\"].max() + margin\n    ymin = df_plantPM[\"Y\"].min() - margin\n    ymax = df_plantPM[\"Y\"].max() + margin\n\n    return xmin, xmax, ymin, ymax\n</code></pre>"},{"location":"api/#netbayesabm.data_analysis.freq_plant","title":"<code>freq_plant(plot, month, df_plant)</code>","text":"<p>Calculate frequency of plant species for a given plot and month.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>str</code> <p>Plot identifier to filter the data.</p> required <code>month</code> <code>int</code> <p>Month to filter the data.</p> required <code>df_plant</code> <code>DataFrame</code> <p>DataFrame containing plant records. Must include columns: - <code>Plot</code> : str - <code>Month</code> : int - <code>Plant_sp_complete</code> : str (full species name)</p> required <p>Returns:</p> Name Type Description <code>df_plant_pm</code> <code>DataFrame</code> <p>Subset of the original DataFrame filtered by plot and month.</p> <code>table_plants</code> <code>DataFrame</code> <p>Frequency table of plant species with columns: - <code>Plant_sp_complete</code> : str - <code>counts</code> : int - <code>Freq</code> : float (relative frequency)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df_sub, freq_table = freq_plant(\"A\", 5, df)\n&gt;&gt;&gt; freq_table.head()\n  Plant_sp_complete  counts  Freq\n0          Rosa sp.       10  0.25\n</code></pre> Source code in <code>netbayesabm/data_analysis.py</code> <pre><code>def freq_plant(\n    plot: str,\n    month: int,\n    df_plant: pd.DataFrame\n) -&gt; tuple[pd.DataFrame, pd.DataFrame]:\n    \"\"\"\n    Calculate frequency of plant species for a given plot and month.\n\n    Parameters\n    ----------\n    plot : str\n        Plot identifier to filter the data.\n    month : int\n        Month to filter the data.\n    df_plant : pandas.DataFrame\n        DataFrame containing plant records. Must include columns:\n        - ``Plot`` : str\n        - ``Month`` : int\n        - ``Plant_sp_complete`` : str (full species name)\n\n    Returns\n    -------\n    df_plant_pm : pandas.DataFrame\n        Subset of the original DataFrame filtered by plot and month.\n    table_plants : pandas.DataFrame\n        Frequency table of plant species with columns:\n        - ``Plant_sp_complete`` : str\n        - ``counts`` : int\n        - ``Freq`` : float (relative frequency)\n\n    Examples\n    --------\n    &gt;&gt;&gt; df_sub, freq_table = freq_plant(\"A\", 5, df)\n    &gt;&gt;&gt; freq_table.head()\n      Plant_sp_complete  counts  Freq\n    0          Rosa sp.       10  0.25\n    \"\"\"\n    df_plant_pm = df_plant.query(\"Plot == @plot and Month == @month\")\n\n    counts = df_plant_pm[\"Plant_sp_complete\"].value_counts().rename(\"counts\")\n    freqs = counts / counts.sum()\n\n    table_plants = (\n        pd.DataFrame({\"counts\": counts, \"Freq\": freqs})\n        .reset_index()\n        .rename(columns={\"index\": \"Plant_sp_complete\"})\n        .round(3)\n    )\n\n    return df_plant_pm, table_plants\n</code></pre>"},{"location":"api/#visualization","title":"Visualization","text":""},{"location":"api/#netbayesabm.visualization--netbayesabm-visualization-module","title":"NetBayesABM - Visualization Module","text":"<p>This module provides visualization tools for plant\u2013pollinator agent-based models (ABM). The functions generate high-quality plots  suitable for analysis, comparison, and publication.</p> <p>Functions:</p> Name Description <code>plot_abundances</code> <p>Plot a histogram of species abundances.</p> <code>plot_priors</code> <p>Plot prior distributions of specialists and generalists.</p> <code>plot_agents</code> <p>Display the spatial distribution of plants and pollinators in the environment.</p> <code>comparative_plot</code> <p>Generic comparative plotting function for pollinators vs plants.</p> <code>box_plot_comp</code> <p>Comparative boxplot of pollinator vs plant distributions.</p> <code>KDE_plot_comp</code> <p>Comparative kernel density estimation (KDE) plot.</p> <code>Cumulative_comp</code> <p>Comparative cumulative histogram of pollinator vs plant distributions.</p> <code>LogLog_comp</code> <p>Comparative log-log histogram of pollinator vs plant distributions.</p> <code>LogLog_comp_scatter</code> <p>Comparative log-log scatter plot of pollinator vs plant distributions.</p> Notes <ul> <li>Most plotting functions return the matplotlib <code>Axes</code> object to    allow further customization.</li> <li>Figures can be optionally saved with high resolution for publication.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netbayesabm import visualization as viz\n&gt;&gt;&gt; ax = viz.plot_abundances(dist, \"abundance_hist\", bins=20, save=True)\n&gt;&gt;&gt; fig, axes = viz.box_plot_comp(deg_pol, deg_pla, \"Degree Distribution\")\n</code></pre>"},{"location":"api/#netbayesabm.visualization.Cumulative_comp","title":"<code>Cumulative_comp(deg_pol, deg_pla, text, show=True)</code>","text":"<p>Comparative cumulative histogram of pollinator vs plant distributions.</p> Source code in <code>netbayesabm/visualization.py</code> <pre><code>def Cumulative_comp(\n    deg_pol: pd.Series | np.ndarray,\n    deg_pla: pd.Series | np.ndarray,\n    text: str,\n    show: bool = True\n):\n    \"\"\"\n    Comparative cumulative histogram of pollinator vs plant distributions.\n    \"\"\"\n    return comparative_plot(\n        deg_pol, deg_pla, text, sns.histplot,\n        show=show, bins=50, stat=\"density\", element=\"step\",\n        fill=False, cumulative=True, common_norm=False\n    )\n</code></pre>"},{"location":"api/#netbayesabm.visualization.KDE_plot_comp","title":"<code>KDE_plot_comp(deg_pol, deg_pla, text, show=True)</code>","text":"<p>Comparative kernel density estimation (KDE) plot for pollinator vs plant distributions.</p> Source code in <code>netbayesabm/visualization.py</code> <pre><code>def KDE_plot_comp(\n    deg_pol: pd.Series | np.ndarray,\n    deg_pla: pd.Series | np.ndarray,\n    text: str,\n    show: bool = True\n):\n    \"\"\"\n    Comparative kernel density estimation (KDE) plot\n    for pollinator vs plant distributions.\n    \"\"\"\n    return comparative_plot(deg_pol, deg_pla, text, sns.kdeplot, show=show)\n</code></pre>"},{"location":"api/#netbayesabm.visualization.LogLog_comp","title":"<code>LogLog_comp(deg_pol, deg_pla, text, show=True)</code>","text":"<p>Comparative log-log histogram of pollinator vs plant distributions.</p> Source code in <code>netbayesabm/visualization.py</code> <pre><code>def LogLog_comp(\n    deg_pol: pd.Series | np.ndarray,\n    deg_pla: pd.Series | np.ndarray,\n    text: str,\n    show: bool = True\n):\n    \"\"\"\n    Comparative log-log histogram of pollinator vs plant distributions.\n    \"\"\"\n    log_deg_pol = np.log(deg_pol)\n    log_deg_pla = np.log(deg_pla)\n    return comparative_plot(\n        log_deg_pol, log_deg_pla, text, sns.histplot,\n        show=show, bins=50, stat=\"density\", element=\"step\",\n        fill=False, common_norm=False\n    )\n</code></pre>"},{"location":"api/#netbayesabm.visualization.LogLog_comp_scatter","title":"<code>LogLog_comp_scatter(deg_pol, deg_pla, text, show=True)</code>","text":"<p>Comparative log-log scatter plot of pollinator vs plant distributions.</p> Source code in <code>netbayesabm/visualization.py</code> <pre><code>def LogLog_comp_scatter(\n    deg_pol: pd.Series | np.ndarray,\n    deg_pla: pd.Series | np.ndarray,\n    text: str,\n    show: bool = True\n):\n    \"\"\"\n    Comparative log-log scatter plot of pollinator vs plant distributions.\n    \"\"\"\n    log_deg_pol = np.log(deg_pol)\n    log_deg_pla = np.log(deg_pla)\n    return comparative_plot(\n        log_deg_pol, log_deg_pla, text, sns.scatterplot, show=show\n    )\n</code></pre>"},{"location":"api/#netbayesabm.visualization.box_plot_comp","title":"<code>box_plot_comp(deg_pol, deg_pla, text, show=True)</code>","text":"<p>Comparative boxplot of pollinator vs plant distributions.</p> Source code in <code>netbayesabm/visualization.py</code> <pre><code>def box_plot_comp(\n    deg_pol: pd.Series | np.ndarray,\n    deg_pla: pd.Series | np.ndarray,\n    text: str,\n    show: bool = True\n):\n    \"\"\"\n    Comparative boxplot of pollinator vs plant distributions.\n    \"\"\"\n    return comparative_plot(deg_pol, deg_pla, text, sns.boxplot, show=show)\n</code></pre>"},{"location":"api/#netbayesabm.visualization.comparative_plot","title":"<code>comparative_plot(deg_pol, deg_pla, text, plot_function, show=True, **kwargs)</code>","text":"<p>Generic comparative plot of pollinator vs plant degree distributions.</p> <p>Parameters:</p> Name Type Description Default <code>deg_pol</code> <code>Series or ndarray</code> <p>Degree distribution (or other metric) for pollinators.</p> required <code>deg_pla</code> <code>Series or ndarray</code> <p>Degree distribution (or other metric) for plants.</p> required <code>text</code> <code>str</code> <p>Label used in plot titles (e.g., \"Degree distribution\").</p> required <code>plot_function</code> <code>callable</code> <p>Plotting function (e.g., seaborn.boxplot, seaborn.histplot). Must accept <code>ax</code> and <code>data</code> as arguments.</p> required <code>show</code> <code>bool</code> <p>If True, displays the figure with <code>plt.show()</code>.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments passed to <code>plot_function</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>The created figure.</p> <code>axes</code> <code>ndarray</code> <p>Array of matplotlib.axes.Axes objects (length 2).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; comparative_plot(deg_pol, deg_pla, \"Degree\", sns.boxplot)\n</code></pre> Source code in <code>netbayesabm/visualization.py</code> <pre><code>def comparative_plot(\n    deg_pol: pd.Series | np.ndarray,\n    deg_pla: pd.Series | np.ndarray,\n    text: str,\n    plot_function,\n    show: bool = True,\n    **kwargs\n) -&gt; tuple[plt.Figure, np.ndarray]:\n    \"\"\"\n    Generic comparative plot of pollinator vs plant degree distributions.\n\n    Parameters\n    ----------\n    deg_pol : pandas.Series or numpy.ndarray\n        Degree distribution (or other metric) for pollinators.\n    deg_pla : pandas.Series or numpy.ndarray\n        Degree distribution (or other metric) for plants.\n    text : str\n        Label used in plot titles (e.g., \"Degree distribution\").\n    plot_function : callable\n        Plotting function (e.g., seaborn.boxplot, seaborn.histplot).\n        Must accept `ax` and `data` as arguments.\n    show : bool, default=True\n        If True, displays the figure with `plt.show()`.\n    **kwargs\n        Additional keyword arguments passed to `plot_function`.\n\n    Returns\n    -------\n    fig : matplotlib.figure.Figure\n        The created figure.\n    axes : numpy.ndarray\n        Array of matplotlib.axes.Axes objects (length 2).\n\n    Examples\n    --------\n    &gt;&gt;&gt; comparative_plot(deg_pol, deg_pla, \"Degree\", sns.boxplot)\n    \"\"\"\n    fig, axes = plt.subplots(1, 2, figsize=(12, 5), dpi=300)\n\n    axes[0].set_title(text + \" of Pollinators\")\n    plot_function(ax=axes[0], data=deg_pol, **kwargs)\n\n    axes[1].set_title(text + \" of Plants\")\n    plot_function(ax=axes[1], data=deg_pla, **kwargs)\n\n    if show:\n        plt.show()\n\n    return fig, axes\n</code></pre>"},{"location":"api/#netbayesabm.visualization.plot_abundances","title":"<code>plot_abundances(dist_pol, name_file, bins=30, save=False)</code>","text":"<p>Plot a histogram of species abundances with publication-quality settings.</p> <p>Parameters:</p> Name Type Description Default <code>dist_pol</code> <code>Series or DataFrame</code> <p>Abundance data of species. If DataFrame, each column is treated separately.</p> required <code>name_file</code> <code>str</code> <p>Title for the plot. If <code>save=True</code>, this string is also used as the filename.</p> required <code>bins</code> <code>int</code> <p>Number of bins in the histogram.</p> <code>30</code> <code>save</code> <code>bool</code> <p>If True, saves the figure to <code>&lt;name_file&gt;.png</code> with high resolution.</p> <code>False</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The Axes object of the generated plot.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; dist = pd.Series([10, 12, 15, 7, 20, 30])\n&gt;&gt;&gt; ax = plot_abundances(dist, \"abundance_hist\", bins=5, save=False)\n</code></pre> Source code in <code>netbayesabm/visualization.py</code> <pre><code>def plot_abundances(\n    dist_pol: pd.Series | pd.DataFrame,\n    name_file: str,\n    bins: int = 30,\n    save: bool = False\n) -&gt; plt.Axes:\n    \"\"\"\n    Plot a histogram of species abundances with publication-quality settings.\n\n    Parameters\n    ----------\n    dist_pol : pandas.Series or pandas.DataFrame\n        Abundance data of species. If DataFrame, each column is treated separately.\n    name_file : str\n        Title for the plot. If `save=True`, this string is also used as the filename.\n    bins : int, default=30\n        Number of bins in the histogram.\n    save : bool, default=False\n        If True, saves the figure to `&lt;name_file&gt;.png` with high resolution.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The Axes object of the generated plot.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; dist = pd.Series([10, 12, 15, 7, 20, 30])\n    &gt;&gt;&gt; ax = plot_abundances(dist, \"abundance_hist\", bins=5, save=False)\n    \"\"\"\n    sns.set(style=\"whitegrid\")\n    fig, ax = plt.subplots(figsize=(10, 6), dpi=300)\n\n    dist_pol.hist(bins=bins, color=\"skyblue\", edgecolor=\"black\", ax=ax)\n    ax.set_xlabel(\"P(Abundances)\", fontsize=12)\n    ax.set_ylabel(\"Number of Species\", fontsize=12)\n    ax.set_title(name_file, fontsize=14)\n\n    if save:\n        fig.savefig(f\"{name_file}.png\", dpi=300, bbox_inches=\"tight\")\n\n    return ax\n</code></pre>"},{"location":"api/#netbayesabm.visualization.plot_agents","title":"<code>plot_agents(env_plant, env_pol, plot, month, xmin, xmax, ymin, ymax, save=False)</code>","text":"<p>Plot the spatial distribution of plant and pollinator agents.</p> <p>Parameters:</p> Name Type Description Default <code>env_plant</code> <code>Environment_plant</code> <p>Environment containing the list of plant agents (<code>plant_list</code>).</p> required <code>env_pol</code> <code>Environment_pol</code> <p>Environment containing the list of pollinator agents (<code>pol_list</code>).</p> required <code>plot</code> <code>str</code> <p>Identifier of the plot (for title).</p> required <code>month</code> <code>int</code> <p>Month identifier (for title).</p> required <code>xmin</code> <code>float</code> <p>Spatial boundaries of the environment.</p> required <code>xmax</code> <code>float</code> <p>Spatial boundaries of the environment.</p> required <code>ymin</code> <code>float</code> <p>Spatial boundaries of the environment.</p> required <code>ymax</code> <code>float</code> <p>Spatial boundaries of the environment.</p> required <code>save</code> <code>bool</code> <p>If True, saves the figure as <code>agents_plot_&lt;plot&gt;_&lt;month&gt;.png</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The Axes object of the generated plot.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ax = plot_agents(env_plants, env_pols, \"A\", 5, 0, 10, 0, 10)\n&gt;&gt;&gt; ax.get_title()\n'Plant and Pollinator Locations: Plot A month 5'\n</code></pre> Source code in <code>netbayesabm/visualization.py</code> <pre><code>def plot_agents(\n    env_plant,\n    env_pol,\n    plot: str,\n    month: int,\n    xmin: float,\n    xmax: float,\n    ymin: float,\n    ymax: float,\n    save: bool = False\n) -&gt; plt.Axes:\n    \"\"\"\n    Plot the spatial distribution of plant and pollinator agents.\n\n    Parameters\n    ----------\n    env_plant : Environment_plant\n        Environment containing the list of plant agents (`plant_list`).\n    env_pol : Environment_pol\n        Environment containing the list of pollinator agents (`pol_list`).\n    plot : str\n        Identifier of the plot (for title).\n    month : int\n        Month identifier (for title).\n    xmin, xmax, ymin, ymax : float\n        Spatial boundaries of the environment.\n    save : bool, default=False\n        If True, saves the figure as `agents_plot_&lt;plot&gt;_&lt;month&gt;.png`.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The Axes object of the generated plot.\n\n    Examples\n    --------\n    &gt;&gt;&gt; ax = plot_agents(env_plants, env_pols, \"A\", 5, 0, 10, 0, 10)\n    &gt;&gt;&gt; ax.get_title()\n    'Plant and Pollinator Locations: Plot A month 5'\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(10, 10), dpi=300)\n\n    for plant in env_plant.plant_list:\n        ax.scatter(plant.x, plant.y, color=\"green\", label=\"Plants\")\n\n    for pol in env_pol.pol_list:\n        ax.scatter(pol.x, pol.y, color=\"red\", label=\"Pollinators\")\n\n    # Remove duplicate labels in legend\n    handles, labels = ax.get_legend_handles_labels()\n    by_label = dict(zip(labels, handles))\n    ax.legend(by_label.values(), by_label.keys())\n\n    ax.set_xlim([xmin, xmax])\n    ax.set_ylim([ymin, ymax])\n    ax.set_title(f\"Plant and Pollinator Locations: Plot {plot} month {month}\")\n    ax.set_xlabel(\"X coordinate\")\n    ax.set_ylabel(\"Y coordinate\")\n\n    if save:\n        fig.savefig(f\"agents_plot_{plot}_{month}.png\", dpi=300, bbox_inches=\"tight\")\n\n    return ax\n</code></pre>"},{"location":"api/#netbayesabm.visualization.plot_priors","title":"<code>plot_priors(prior_e, prior_g, name_priors, bins=100, save=False)</code>","text":"<p>Plot histograms of prior distributions for specialists and generalists.</p> <p>Parameters:</p> Name Type Description Default <code>prior_e</code> <code>Series or ndarray</code> <p>Prior distribution values for specialists.</p> required <code>prior_g</code> <code>Series or ndarray</code> <p>Prior distribution values for generalists.</p> required <code>name_priors</code> <code>str</code> <p>Suffix for the plot title. If <code>save=True</code>, also used as filename.</p> required <code>bins</code> <code>int</code> <p>Number of bins for the histograms.</p> <code>100</code> <code>save</code> <code>bool</code> <p>If True, saves the figure as <code>&lt;name_priors&gt;_priors.png</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The Axes object of the generated plot.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; prior_e = np.random.gamma(2, 1, 1000)\n&gt;&gt;&gt; prior_g = np.random.gamma(5, 1, 1000)\n&gt;&gt;&gt; ax = plot_priors(prior_e, prior_g, \"example\")\n</code></pre> Source code in <code>netbayesabm/visualization.py</code> <pre><code>def plot_priors(\n    prior_e: pd.Series | np.ndarray,\n    prior_g: pd.Series | np.ndarray,\n    name_priors: str,\n    bins: int = 100,\n    save: bool = False\n) -&gt; plt.Axes:\n    \"\"\"\n    Plot histograms of prior distributions for specialists and generalists.\n\n    Parameters\n    ----------\n    prior_e : pandas.Series or numpy.ndarray\n        Prior distribution values for specialists.\n    prior_g : pandas.Series or numpy.ndarray\n        Prior distribution values for generalists.\n    name_priors : str\n        Suffix for the plot title. If `save=True`, also used as filename.\n    bins : int, default=100\n        Number of bins for the histograms.\n    save : bool, default=False\n        If True, saves the figure as `&lt;name_priors&gt;_priors.png`.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The Axes object of the generated plot.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; prior_e = np.random.gamma(2, 1, 1000)\n    &gt;&gt;&gt; prior_g = np.random.gamma(5, 1, 1000)\n    &gt;&gt;&gt; ax = plot_priors(prior_e, prior_g, \"example\")\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(8, 5), dpi=300)\n\n    ax.hist(prior_e, bins=bins, alpha=0.5, label=\"prior_specialists\", density=True)\n    ax.hist(prior_g, bins=bins, alpha=0.5, label=\"prior_generalists\", density=True)\n\n    ax.set_title(f\"Priors gamma {name_priors}\")\n    ax.set_xlabel(\"Value\")\n    ax.set_ylabel(\"Density\")\n    ax.legend()\n\n    if save:\n        fig.savefig(f\"{name_priors}_priors.png\", dpi=300, bbox_inches=\"tight\")\n\n    return ax\n</code></pre>"},{"location":"api/#metrics-abc","title":"Metrics (ABC)","text":""},{"location":"api/#netbayesabm.abc_module.metrics--netbayesabm-metrics-module","title":"NetBayesABM - Metrics Module","text":"<p>This module provides distance and divergence metrics for comparing empirical and simulated data in plant\u2013pollinator agent-based models (ABM).</p> <p>Functions:</p> Name Description <code>hellinger_distance</code> <p>Compute the Hellinger distance between two probability distributions.</p> <code>compute_metrics</code> <p>Calculate multiple metrics (Jensen\u2013Shannon, KS, Wasserstein, Hellinger, MAE, KL) across simulation iterations.</p> Notes <ul> <li>Input data is expected as probability distributions or count vectors   (depending on the metric).</li> <li>All metrics are computed in a vectorized way for efficiency.</li> </ul> References <ul> <li>Jensen\u2013Shannon divergence: https://en.wikipedia.org/wiki/Jensen%E2%80%93Shannon_divergence</li> <li>Hellinger distance: https://en.wikipedia.org/wiki/Hellinger_distance</li> <li>Kolmogorov\u2013Smirnov test: https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test</li> <li>Wasserstein distance: https://en.wikipedia.org/wiki/Wasserstein_metric</li> </ul>"},{"location":"api/#netbayesabm.abc_module.metrics.compute_metrics","title":"<code>compute_metrics(df)</code>","text":"<p>Compute multiple metrics to compare real vs model distributions across simulation iterations.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame containing the following columns: - <code>iteration</code> : identifier of the simulation run - <code>Real</code> : observed values (counts or frequencies) - <code>Model</code> : simulated values - <code>r_esp</code> : parameter value for specialists (constant within iteration) - <code>r_gen</code> : parameter value for generalists (constant within iteration)</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with one row per iteration, containing: - <code>iteration</code> : int - <code>JS_divergence</code> : float - <code>KS_distance</code> : float - <code>Wasserstein_distance</code> : float - <code>Hellinger_distance</code> : float - <code>MAE</code> : float (relative mean absolute error) - <code>KL_divergence</code> : float - <code>r_esp</code> : float - <code>r_gen</code> : float</p> Notes <ul> <li>Probabilities are normalized with a small epsilon (1e-10) to avoid zero divisions.</li> <li>Jensen\u2013Shannon divergence is squared (scipy returns the square root by default).</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"iteration\": [1, 1, 2, 2],\n...     \"Real\": [10, 20, 5, 15],\n...     \"Model\": [12, 18, 6, 14],\n...     \"r_esp\": [0.1, 0.1, 0.2, 0.2],\n...     \"r_gen\": [0.5, 0.5, 0.6, 0.6]\n... })\n&gt;&gt;&gt; results = compute_metrics(df)\n&gt;&gt;&gt; results[[\"iteration\", \"JS_divergence\", \"MAE\"]]\n   iteration  JS_divergence       MAE\n0          1        0.000123  0.100000\n1          2        0.000234  0.066667\n</code></pre> Source code in <code>netbayesabm/abc_module/metrics.py</code> <pre><code>def compute_metrics(df: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute multiple metrics to compare real vs model distributions\n    across simulation iterations.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        DataFrame containing the following columns:\n        - ``iteration`` : identifier of the simulation run\n        - ``Real`` : observed values (counts or frequencies)\n        - ``Model`` : simulated values\n        - ``r_esp`` : parameter value for specialists (constant within iteration)\n        - ``r_gen`` : parameter value for generalists (constant within iteration)\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with one row per iteration, containing:\n        - ``iteration`` : int\n        - ``JS_divergence`` : float\n        - ``KS_distance`` : float\n        - ``Wasserstein_distance`` : float\n        - ``Hellinger_distance`` : float\n        - ``MAE`` : float (relative mean absolute error)\n        - ``KL_divergence`` : float\n        - ``r_esp`` : float\n        - ``r_gen`` : float\n\n    Notes\n    -----\n    - Probabilities are normalized with a small epsilon (1e-10) to avoid zero divisions.\n    - Jensen\u2013Shannon divergence is squared (scipy returns the square root by default).\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; df = pd.DataFrame({\n    ...     \"iteration\": [1, 1, 2, 2],\n    ...     \"Real\": [10, 20, 5, 15],\n    ...     \"Model\": [12, 18, 6, 14],\n    ...     \"r_esp\": [0.1, 0.1, 0.2, 0.2],\n    ...     \"r_gen\": [0.5, 0.5, 0.6, 0.6]\n    ... })\n    &gt;&gt;&gt; results = compute_metrics(df)\n    &gt;&gt;&gt; results[[\"iteration\", \"JS_divergence\", \"MAE\"]]\n       iteration  JS_divergence       MAE\n    0          1        0.000123  0.100000\n    1          2        0.000234  0.066667\n    \"\"\"\n    results = []\n\n    for iteration, group in df.groupby(\"iteration\"):\n        real = group[\"Real\"].values\n        model = group[\"Model\"].values\n\n        # Normalizar para comparaciones basadas en probabilidad\n        real_dist = real / real.sum() if real.sum() &gt; 0 else np.ones_like(real) / len(real)\n        model_dist = model / model.sum() if model.sum() &gt; 0 else np.ones_like(model) / len(model)\n\n        epsilon = 1e-10\n        real_dist = np.clip(real_dist, epsilon, 1)\n        model_dist = np.clip(model_dist, epsilon, 1)\n\n        # Calcular m\u00e9tricas\n        js_div = jensenshannon(real_dist, model_dist, base=np.e) ** 2\n        ks_stat, _ = ks_2samp(real, model)\n        wass_dist = wasserstein_distance(real, model)\n        hell_dist = hellinger_distance(real_dist, model_dist)\n        mae = np.mean(np.abs(model - real) / np.clip(real, epsilon, None))\n        kl_div = np.sum(real_dist * np.log(real_dist / model_dist))\n\n        r_esp = group[\"r_esp\"].iloc[0]\n        r_gen = group[\"r_gen\"].iloc[0]\n\n        results.append({\n            \"iteration\": iteration,\n            \"JS_divergence\": js_div,\n            \"KS_distance\": ks_stat,\n            \"Wasserstein_distance\": wass_dist,\n            \"Hellinger_distance\": hell_dist,\n            \"Relative_MAE\": mae,\n            \"Absolute_MAE\": np.mean(np.abs(model - real)),\n            \"KL_divergence\": kl_div,\n            \"r_esp\": r_esp,\n            \"r_gen\": r_gen\n        })\n\n    return pd.DataFrame(results)\n</code></pre>"},{"location":"api/#netbayesabm.abc_module.metrics.hellinger_distance","title":"<code>hellinger_distance(p, q)</code>","text":"<p>Compute the Hellinger distance between two probability distributions.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>ndarray</code> <p>First probability distribution (1D, must sum to 1).</p> required <code>q</code> <code>ndarray</code> <p>Second probability distribution (1D, must sum to 1).</p> required <p>Returns:</p> Type Description <code>float</code> <p>Hellinger distance in [0, 1].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; p = np.array([0.4, 0.6])\n&gt;&gt;&gt; q = np.array([0.5, 0.5])\n&gt;&gt;&gt; hellinger_distance(p, q)\n0.070710678...\n</code></pre> Source code in <code>netbayesabm/abc_module/metrics.py</code> <pre><code>def hellinger_distance(p: np.ndarray, q: np.ndarray) -&gt; float:\n    \"\"\"\n    Compute the Hellinger distance between two probability distributions.\n\n    Parameters\n    ----------\n    p : numpy.ndarray\n        First probability distribution (1D, must sum to 1).\n    q : numpy.ndarray\n        Second probability distribution (1D, must sum to 1).\n\n    Returns\n    -------\n    float\n        Hellinger distance in [0, 1].\n\n    Examples\n    --------\n    &gt;&gt;&gt; p = np.array([0.4, 0.6])\n    &gt;&gt;&gt; q = np.array([0.5, 0.5])\n    &gt;&gt;&gt; hellinger_distance(p, q)\n    0.070710678...\n    \"\"\"\n    return np.sqrt(0.5 * np.sum((np.sqrt(p) - np.sqrt(q))**2))\n</code></pre>"},{"location":"api/#netbayesabm.abc_module.metrics.plot_degree_comp","title":"<code>plot_degree_comp(data, plot_month)</code>","text":"<p>Compare real vs. simulated degree distributions for each species and plot the results.</p> <p>The function aggregates model outputs by species across iterations, computes absolute error and RMSE with respect to real values, and visualizes: - Real degrees - Mean model degrees - Min\u2013max model range - Absolute error - RMSE</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame with the following required columns: - <code>iteration</code> : simulation run identifier - <code>Unnamed: 0</code> : species identifier - <code>Model</code> : simulated degree value - <code>Real</code> : observed degree value (same across iterations)</p> required <code>plot_month</code> <code>str</code> <p>Label used in the plot title and output filename (e.g. <code>\"May_2023\"</code>).</p> required <p>Returns:</p> Type Description <code>float</code> <p>Total absolute error across all species.</p> Notes <ul> <li>The figure is shown but not saved by default.</li> <li>To save the figure, uncomment the <code>plt.savefig</code> line.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     \"iteration\": [1, 1, 2, 2],\n...     \"Unnamed: 0\": [\"sp1\", \"sp2\", \"sp1\", \"sp2\"],\n...     \"Model\": [5, 10, 6, 9],\n...     \"Real\": [5, 12, 5, 12]\n... })\n&gt;&gt;&gt; total_error = plot_degree_comp(df, \"TestMonth\")\n&gt;&gt;&gt; round(total_error, 2)\n3.0\n</code></pre> Source code in <code>netbayesabm/abc_module/metrics.py</code> <pre><code>def plot_degree_comp(\n    data: pd.DataFrame,\n    plot_month: str\n) -&gt; float:\n    \"\"\"\n    Compare real vs. simulated degree distributions for each species and plot the results.\n\n    The function aggregates model outputs by species across iterations, computes\n    absolute error and RMSE with respect to real values, and visualizes:\n    - Real degrees\n    - Mean model degrees\n    - Min\u2013max model range\n    - Absolute error\n    - RMSE\n\n    Parameters\n    ----------\n    data : pandas.DataFrame\n        DataFrame with the following required columns:\n        - ``iteration`` : simulation run identifier\n        - ``Unnamed: 0`` : species identifier\n        - ``Model`` : simulated degree value\n        - ``Real`` : observed degree value (same across iterations)\n    plot_month : str\n        Label used in the plot title and output filename (e.g. `\"May_2023\"`).\n\n    Returns\n    -------\n    float\n        Total absolute error across all species.\n\n    Notes\n    -----\n    - The figure is shown but not saved by default.\n    - To save the figure, uncomment the `plt.savefig` line.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pd.DataFrame({\n    ...     \"iteration\": [1, 1, 2, 2],\n    ...     \"Unnamed: 0\": [\"sp1\", \"sp2\", \"sp1\", \"sp2\"],\n    ...     \"Model\": [5, 10, 6, 9],\n    ...     \"Real\": [5, 12, 5, 12]\n    ... })\n    &gt;&gt;&gt; total_error = plot_degree_comp(df, \"TestMonth\")\n    &gt;&gt;&gt; round(total_error, 2)\n    3.0\n    \"\"\"\n    # Aggregate by species\n    summary = data.groupby(\"Unnamed: 0\").agg(\n        mean_model=(\"Model\", \"mean\"),\n        std_model=(\"Model\", \"std\"),\n        min_model=(\"Model\", \"min\"),\n        max_model=(\"Model\", \"max\"),\n        real_degree=(\"Real\", \"first\")  # real degree is constant across iterations\n    ).reset_index()\n\n    # Model matrix for RMSE\n    model_matrix = data.pivot_table(\n        index=\"iteration\", columns=\"Unnamed: 0\", values=\"Model\", aggfunc=\"mean\"\n    )\n    species = summary[\"Unnamed: 0\"].values\n    real = summary[\"real_degree\"].values\n    mean_model = summary[\"mean_model\"].values\n\n    # Errors\n    abs_error = np.abs(mean_model - real)\n    rmse = np.sqrt(np.mean((model_matrix[species].values - real) ** 2, axis=0))\n    total_abs_error = abs_error.sum()\n\n    # Plot\n    plt.figure(figsize=(14, 6))\n    plt.plot(species, real, marker=\"o\", linestyle=\"-\", label=\"Real\", linewidth=2)\n    plt.plot(species, mean_model, marker=\"s\", linestyle=\"--\", label=\"Model Mean\", linewidth=1)\n    plt.fill_between(\n        species,\n        summary[\"min_model\"],\n        summary[\"max_model\"],\n        color=\"gray\",\n        alpha=0.3,\n        label=\"Model Min-Max Range\"\n    )\n\n    # Error curves\n    plt.plot(species, abs_error, linestyle=\"dotted\", marker=\"x\", color=\"red\", label=\"Abs. Error\")\n    plt.plot(species, rmse, linestyle=\"dashdot\", marker=\"d\", color=\"purple\", label=\"RMSE\")\n\n    name = f\"Top10_{plot_month}.png\"\n    plt.title(f\"{name} \u2014 Total Abs. Error: {total_abs_error:.2f}\")\n    plt.xticks(rotation=90)\n    plt.xlabel(\"Species\")\n    plt.ylabel(\"Degree\")\n    plt.legend()\n    plt.tight_layout()\n    # plt.savefig(name)\n\n    return total_abs_error\n</code></pre>"},{"location":"api/#netbayesabm.abc_module.metrics.resume_error","title":"<code>resume_error(df)</code>","text":"<p>Summarize model vs. real values by species, computing error metrics.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame containing at least the following columns: - <code>Unnamed: 0</code> : species identifier - <code>Real</code> : observed values - <code>Model</code> : simulated values</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with one row per species, including: - <code>especie</code> : species identifier - <code>real_value</code> : observed value (constant per species) - <code>model_mean</code> : mean simulated value - <code>model_std</code> : standard deviation of simulated values - <code>model_min</code> : minimum simulated value - <code>model_max</code> : maximum simulated value - <code>abs_error</code> : absolute error between real and mean simulated - <code>z_score</code> : absolute error normalized by model standard deviation - <code>model_range</code> : range (max - min) of simulated values - <code>z_range</code> : absolute error normalized by model range</p> Notes <ul> <li><code>z_score</code> and <code>z_range</code> are set to NaN if the denominator is zero.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"Unnamed: 0\": [\"sp1\", \"sp1\", \"sp2\", \"sp2\"],\n...     \"Real\": [10, 10, 5, 5],\n...     \"Model\": [9, 11, 4, 6]\n... })\n&gt;&gt;&gt; summary = resume_error(df)\n&gt;&gt;&gt; summary[[\"especie\", \"abs_error\"]]\n  especie  abs_error\n0     sp1        0.0\n1     sp2        0.0\n</code></pre> Source code in <code>netbayesabm/abc_module/metrics.py</code> <pre><code>def resume_error(df: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    Summarize model vs. real values by species, computing error metrics.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        DataFrame containing at least the following columns:\n        - ``Unnamed: 0`` : species identifier\n        - ``Real`` : observed values\n        - ``Model`` : simulated values\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with one row per species, including:\n        - ``especie`` : species identifier\n        - ``real_value`` : observed value (constant per species)\n        - ``model_mean`` : mean simulated value\n        - ``model_std`` : standard deviation of simulated values\n        - ``model_min`` : minimum simulated value\n        - ``model_max`` : maximum simulated value\n        - ``abs_error`` : absolute error between real and mean simulated\n        - ``z_score`` : absolute error normalized by model standard deviation\n        - ``model_range`` : range (max - min) of simulated values\n        - ``z_range`` : absolute error normalized by model range\n\n    Notes\n    -----\n    - ``z_score`` and ``z_range`` are set to NaN if the denominator is zero.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; df = pd.DataFrame({\n    ...     \"Unnamed: 0\": [\"sp1\", \"sp1\", \"sp2\", \"sp2\"],\n    ...     \"Real\": [10, 10, 5, 5],\n    ...     \"Model\": [9, 11, 4, 6]\n    ... })\n    &gt;&gt;&gt; summary = resume_error(df)\n    &gt;&gt;&gt; summary[[\"especie\", \"abs_error\"]]\n      especie  abs_error\n    0     sp1        0.0\n    1     sp2        0.0\n    \"\"\"\n    df = df.copy()\n\n    grouped = df.groupby(\"Unnamed: 0\").agg(\n        real_value=(\"Real\", \"mean\"),   # should be constant per species\n        model_mean=(\"Model\", \"mean\"),\n        model_std=(\"Model\", \"std\"),\n        model_min=(\"Model\", \"min\"),\n        model_max=(\"Model\", \"max\")\n    ).reset_index()\n\n    grouped[\"abs_error\"] = np.abs(grouped[\"real_value\"] - grouped[\"model_mean\"])\n\n    grouped[\"z_score\"] = np.where(\n        grouped[\"model_std\"] &gt; 0,\n        grouped[\"abs_error\"] / grouped[\"model_std\"],\n        np.nan\n    )\n\n    grouped[\"model_range\"] = grouped[\"model_max\"] - grouped[\"model_min\"]\n    grouped[\"z_range\"] = np.where(\n        grouped[\"model_range\"] &gt; 0,\n        grouped[\"abs_error\"] / grouped[\"model_range\"],\n        np.nan\n    )\n\n    grouped = grouped.rename(columns={\"Unnamed: 0\": \"especie\"})\n\n    return grouped\n</code></pre>"},{"location":"api/#netbayesabm.abc_module.metrics.top_metric","title":"<code>top_metric(df_metrics, metric, top_fraction=0.1)</code>","text":"<p>Select the top fraction of rows based on a given metric.</p> <p>Parameters:</p> Name Type Description Default <code>df_metrics</code> <code>DataFrame</code> <p>DataFrame containing evaluation results and metrics.</p> required <code>metric</code> <code>str</code> <p>Name of the column used to rank the rows.</p> required <code>top_fraction</code> <code>float</code> <p>Fraction of top rows to keep (between 0 and 1). At least one row is always returned.</p> <code>0.1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Subset of the DataFrame with the top-ranked rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame({\"iteration\": [1, 2, 3],\n...                    \"score\": [0.2, 0.8, 0.5]})\n&gt;&gt;&gt; top_metric(df, \"score\", top_fraction=0.33)\n   iteration  score\n1          2    0.8\n</code></pre> Source code in <code>netbayesabm/abc_module/metrics.py</code> <pre><code>def top_metric(\n    df_metrics: pd.DataFrame,\n    metric: str,\n    top_fraction: float = 0.1\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Select the top fraction of rows based on a given metric.\n\n    Parameters\n    ----------\n    df_metrics : pandas.DataFrame\n        DataFrame containing evaluation results and metrics.\n    metric : str\n        Name of the column used to rank the rows.\n    top_fraction : float, default=0.1\n        Fraction of top rows to keep (between 0 and 1).\n        At least one row is always returned.\n\n    Returns\n    -------\n    pandas.DataFrame\n        Subset of the DataFrame with the top-ranked rows.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; df = pd.DataFrame({\"iteration\": [1, 2, 3],\n    ...                    \"score\": [0.2, 0.8, 0.5]})\n    &gt;&gt;&gt; top_metric(df, \"score\", top_fraction=0.33)\n       iteration  score\n    1          2    0.8\n    \"\"\"\n    df_sorted = df_metrics.sort_values(by=metric, ascending=False)\n    top_n = max(1, int(len(df_sorted) * top_fraction))\n    return df_sorted.head(top_n)\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>To install the stable release from PyPI:</p> <pre><code>pip install netbayesabm\n</code></pre> <p>For development (latest code from GitHub):</p> <pre><code>git clone https://github.com/galeanojav/NetBayesABM.git\ncd NetBayesABM\npip install -e .\n</code></pre>"},{"location":"usage/example/","title":"Examples","text":"In\u00a0[32]: Copied! <pre># Standard libraries\nimport os\nimport warnings\nimport sys\nsys.path.append(os.path.abspath(\"../\"))  # subir un nivel y entrar en src\n\n\n# Third-party libraries\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom networkx.convert_matrix import to_pandas_adjacency\n</pre> # Standard libraries import os import warnings import sys sys.path.append(os.path.abspath(\"../\"))  # subir un nivel y entrar en src   # Third-party libraries import numpy as np import pandas as pd import matplotlib.pyplot as plt from networkx.convert_matrix import to_pandas_adjacency  In\u00a0[16]: Copied! <pre># Custom modules\nfrom classes import Environment_plant, Environment_pol\nfrom data_analysis import area_plot\nfrom modelling import (\n    initial_network,\n    update_totalinks,\n    remove_zero,\n    degree_dist,\n    initial_pollinators_random,\n)\nfrom visualization import plot_abundances, plot_priors\n#import nxproperties as nxp\n\n# Ignore all warnings (use with caution)\nwarnings.filterwarnings('ignore')\n</pre> # Custom modules from classes import Environment_plant, Environment_pol from data_analysis import area_plot from modelling import (     initial_network,     update_totalinks,     remove_zero,     degree_dist,     initial_pollinators_random, ) from visualization import plot_abundances, plot_priors #import nxproperties as nxp  # Ignore all warnings (use with caution) warnings.filterwarnings('ignore')  In\u00a0[26]: Copied! <pre># Directory where output files will be saved\noutput_dir = \"Output_analysis\"\nos.makedirs(output_dir, exist_ok=True)\n</pre> # Directory where output files will be saved output_dir = \"Output_analysis\" os.makedirs(output_dir, exist_ok=True) In\u00a0[44]: Copied! <pre># --- Simulation parameters ---\n\n# Number of draws from the prior distribution\nn_draws = 100\n\n# Plot and time slice selection\nselected_plot = 'A'\nslice_index = 3\ninteraction_scale = 5  # Number of pollinators per plant\n\n# Construct the output filename\noutput_filename = f\"{selected_plot}{slice_index}_nd{n_draws}\"\n</pre> # --- Simulation parameters ---  # Number of draws from the prior distribution n_draws = 100  # Plot and time slice selection selected_plot = 'A' slice_index = 3 interaction_scale = 5  # Number of pollinators per plant  # Construct the output filename output_filename = f\"{selected_plot}{slice_index}_nd{n_draws}\"  In\u00a0[45]: Copied! <pre># --- Load interaction network for the selected plot and slice ---\n\nnetwork_path = f\"Data/network_plot_{selected_plot}_slice_{slice_index}.csv\"\ndf_net = pd.read_csv(network_path, sep=';')\ndf_net.head()\n</pre> # --- Load interaction network for the selected plot and slice ---  network_path = f\"Data/network_plot_{selected_plot}_slice_{slice_index}.csv\" df_net = pd.read_csv(network_path, sep=';') df_net.head() Out[45]: Plant_id Acmaeodera_sp Anthrenus_sp Attagenus_sp Bombylius_sp Buprestidae_sp1 Ceratina_sp Chasmatopterus_sp Coptocephala_sp Curculionidae ... Oedemera_sp Paragus_tibialis Phthiria_sp1 Phthiria_sp2 Plebejus_argus Rhyzobius_lophanthae Tiphia_morio Tychius_sp Usia_sp Xylocopa_cantabrita 0 471 0.000000 0.0 0.0 0.0 0.0 0.0 1.387507 0.0 0.000000 ... 0.0 0.0 0.001156 0.000000 0.0 0.0 0.0 0.0 0.001156 0.0 1 472 0.000000 0.0 0.0 0.0 0.0 0.0 1.414657 0.0 0.000000 ... 0.0 0.0 0.000621 0.000621 0.0 0.0 0.0 0.0 0.000000 0.0 2 473 0.001054 0.0 0.0 0.0 0.0 0.0 1.212193 0.0 0.000527 ... 0.0 0.0 0.000000 0.000000 0.0 0.0 0.0 0.0 0.000000 0.0 3 474 0.000000 0.0 0.0 0.0 0.0 0.0 0.000000 0.0 0.000000 ... 0.0 0.0 0.000000 0.390910 0.0 0.0 0.0 0.0 0.000000 0.0 4 475 0.000000 0.0 0.0 0.0 0.0 0.0 0.542555 0.0 0.000000 ... 0.0 0.0 0.000000 0.000000 0.0 0.0 0.0 0.0 0.000000 0.0 <p>5 rows \u00d7 29 columns</p> In\u00a0[46]: Copied! <pre># Extract plant IDs as strings\nplant_list = df_net[\"Plant_id\"].astype(str).tolist()\n\n# --- Load plant coordinates and filter for current plant list ---\n\ndf_plant = pd.read_csv(\"Data/coords_plot_month.csv\", sep=';')\ndf_plant_pm = df_plant.query(\"Plant_id in @plant_list\").drop_duplicates(subset=\"Plant_id\")\n\n# --- Load total number of visits for the selected plot and slice ---\n\ndf_visit = pd.read_csv(\"Data/n_visits_slice_plot.csv\", sep=';')\nnt_links = df_visit.query(\"Slice == @slice_index and Plot == @selected_plot\")[\"Frequency\"].values[0]\n</pre> # Extract plant IDs as strings plant_list = df_net[\"Plant_id\"].astype(str).tolist()  # --- Load plant coordinates and filter for current plant list ---  df_plant = pd.read_csv(\"Data/coords_plot_month.csv\", sep=';') df_plant_pm = df_plant.query(\"Plant_id in @plant_list\").drop_duplicates(subset=\"Plant_id\")  # --- Load total number of visits for the selected plot and slice ---  df_visit = pd.read_csv(\"Data/n_visits_slice_plot.csv\", sep=';') nt_links = df_visit.query(\"Slice == @slice_index and Plot == @selected_plot\")[\"Frequency\"].values[0]  In\u00a0[47]: Copied! <pre># --- Calculate spatial boundaries from plant data ---\nxmin, ymin, xmax, ymax = area_plot(df_plant_pm)\n</pre> # --- Calculate spatial boundaries from plant data --- xmin, ymin, xmax, ymax = area_plot(df_plant_pm)  In\u00a0[48]: Copied! <pre># --- Initialize plant environment ---\n# Creates plant agents with spatial positions (randomly distributed within bounds),\n# species identity, and unique IDs\n\n# --- Initialize plant environment ---\n# Three options available:\n#\n# 1) Default: use coordinates from DataFrame\n#    envp = Environment_plant(df_plant_pm)\n#\n# 2) Random: assign coordinates uniformly within bounds\n#    envp = Environment_plant(df_plant_pm, random_position=True,\n#                             xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)\n#\n# 3) Regular: assign coordinates on a grid within bounds\n#    envp = Environment_plant(df_plant_pm, regular_position=True,\n#                             xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)\n\nenvp = Environment_plant(\n    df_plant_pm,\n    random_position=True,\n    xmin=xmin,\n    xmax=xmax,\n    ymin=ymin,\n    ymax=ymax\n)\n</pre> # --- Initialize plant environment --- # Creates plant agents with spatial positions (randomly distributed within bounds), # species identity, and unique IDs  # --- Initialize plant environment --- # Three options available: # # 1) Default: use coordinates from DataFrame #    envp = Environment_plant(df_plant_pm) # # 2) Random: assign coordinates uniformly within bounds #    envp = Environment_plant(df_plant_pm, random_position=True, #                             xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax) # # 3) Regular: assign coordinates on a grid within bounds #    envp = Environment_plant(df_plant_pm, regular_position=True, #                             xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)  envp = Environment_plant(     df_plant_pm,     random_position=True,     xmin=xmin,     xmax=xmax,     ymin=ymin,     ymax=ymax )  In\u00a0[49]: Copied! <pre># --- Initialize plant environment ---\n\n# Option 1: Use coordinates from DataFrame\nenvp_default = Environment_plant(df_plant_pm)\n\n# Option 2: Assign random coordinates within bounds\nenvp_random = Environment_plant(\n    df_plant_pm.copy(),  # use a copy to avoid overwriting\n    random_position=True,\n    xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax\n)\n\n# Option 3: Assign regular grid coordinates within bounds\nenvp_regular = Environment_plant(\n    df_plant_pm.copy(),\n    regular_position=True,\n    xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax\n)\n</pre> # --- Initialize plant environment ---  # Option 1: Use coordinates from DataFrame envp_default = Environment_plant(df_plant_pm)  # Option 2: Assign random coordinates within bounds envp_random = Environment_plant(     df_plant_pm.copy(),  # use a copy to avoid overwriting     random_position=True,     xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax )  # Option 3: Assign regular grid coordinates within bounds envp_regular = Environment_plant(     df_plant_pm.copy(),     regular_position=True,     xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax ) In\u00a0[50]: Copied! <pre># Number of plant agents\nn_plants = len(envp.plant_list)\n\n# Number of pollinator agents (based on scale)\nn_pollinators = interaction_scale * n_plants\n</pre> # Number of plant agents n_plants = len(envp.plant_list)  # Number of pollinator agents (based on scale) n_pollinators = interaction_scale * n_plants  In\u00a0[51]: Copied! <pre># --- Compute relative abundances of pollinator species ---\n\n# Proportional abundance per species (excluding the first column, assumed to be Plant_id)\ndist_pol = df_net.iloc[:, 1:].sum()\ndist_pol = dist_pol / dist_pol.sum()\ndist_pol = np.round(dist_pol, decimals=4)\n\n# Sort species by abundance to ensure last adjustment is on the largest value\ndist_pol = dist_pol.sort_values()\n\n# Adjust final value to ensure exact sum to 1 (fix for rounding error)\ndist_pol.iloc[-1] += (1.0 - dist_pol.sum())\n\n# --- Count number of unique species ---\n\nn_plant_species = df_plant_pm[\"Plant_sp_complete\"].nunique()\nn_pollinator_species = len(dist_pol.index)\n\n# --- Report summary statistics ---\n\nprint(f\"Number of plant agents: {n_plants}\")\nprint(f\"Number of pollinator agents: {n_pollinators}\")\nprint(f\"Number of plant species: {n_plant_species}\")\nprint(f\"Number of pollinator species: {n_pollinator_species}\")\n</pre> # --- Compute relative abundances of pollinator species ---  # Proportional abundance per species (excluding the first column, assumed to be Plant_id) dist_pol = df_net.iloc[:, 1:].sum() dist_pol = dist_pol / dist_pol.sum() dist_pol = np.round(dist_pol, decimals=4)  # Sort species by abundance to ensure last adjustment is on the largest value dist_pol = dist_pol.sort_values()  # Adjust final value to ensure exact sum to 1 (fix for rounding error) dist_pol.iloc[-1] += (1.0 - dist_pol.sum())  # --- Count number of unique species ---  n_plant_species = df_plant_pm[\"Plant_sp_complete\"].nunique() n_pollinator_species = len(dist_pol.index)  # --- Report summary statistics ---  print(f\"Number of plant agents: {n_plants}\") print(f\"Number of pollinator agents: {n_pollinators}\") print(f\"Number of plant species: {n_plant_species}\") print(f\"Number of pollinator species: {n_pollinator_species}\") <pre>Number of plant agents: 27\nNumber of pollinator agents: 135\nNumber of plant species: 3\nNumber of pollinator species: 28\n</pre> In\u00a0[52]: Copied! <pre># --- Save pollinator abundance distribution ---\n\ndist_pol_path = os.path.join(output_dir, f\"{output_filename}_species_dist_pol_model2.csv\")\ndist_pol.to_csv(dist_pol_path)\n</pre> # --- Save pollinator abundance distribution ---  dist_pol_path = os.path.join(output_dir, f\"{output_filename}_species_dist_pol_model2.csv\") dist_pol.to_csv(dist_pol_path)  In\u00a0[53]: Copied! <pre># Plot and save species abundance distribution\nplot_abundances(dist_pol, output_filename, save=True)\n</pre> # Plot and save species abundance distribution plot_abundances(dist_pol, output_filename, save=True)  Out[53]: <pre>&lt;Axes: title={'center': 'A3_nd100'}, xlabel='P(Abundances)', ylabel='Number of Species'&gt;</pre> In\u00a0[54]: Copied! <pre># Generate priors (r distributions for specialists and generalists) ---\n\n# Parameters for gamma distributions\nshape_specialist = 2\nshape_generalist = 5\nscale_specialist = 2\nscale_generalist = 1\n\n# Name suffix for saving prior plots or files\nprior_name = f\"_gamma_s{shape_specialist}_{shape_generalist}_sc{scale_specialist}_{scale_generalist}\"\n</pre> # Generate priors (r distributions for specialists and generalists) ---  # Parameters for gamma distributions shape_specialist = 2 shape_generalist = 5 scale_specialist = 2 scale_generalist = 1  # Name suffix for saving prior plots or files prior_name = f\"_gamma_s{shape_specialist}_{shape_generalist}_sc{scale_specialist}_{scale_generalist}\"  In\u00a0[55]: Copied! <pre># Generate gamma-distributed priors\nprior_specialist = pd.Series(np.random.gamma(shape_specialist, scale_specialist, size=n_draws))\nprior_generalist = pd.Series(np.random.gamma(shape_generalist, scale_generalist, size=n_draws))\n\n# ---- Option B: Exponential distributions (alternative) ----\n# exp_specialist = 10\n# exp_generalist = 20\n# prior_name = f\"_exp_s{exp_specialist}_{exp_generalist}\"\n# prior_specialist = pd.Series(np.random.exponential(scale=exp_specialist, size=n_draws))\n# prior_generalist = pd.Series(np.random.exponential(scale=exp_generalist, size=n_draws))\n\n\n# Optional: plot prior distributions\n# plot_priors(prior_specialist, prior_generalist, prior_name)\n</pre> # Generate gamma-distributed priors prior_specialist = pd.Series(np.random.gamma(shape_specialist, scale_specialist, size=n_draws)) prior_generalist = pd.Series(np.random.gamma(shape_generalist, scale_generalist, size=n_draws))  # ---- Option B: Exponential distributions (alternative) ---- # exp_specialist = 10 # exp_generalist = 20 # prior_name = f\"_exp_s{exp_specialist}_{exp_generalist}\" # prior_specialist = pd.Series(np.random.exponential(scale=exp_specialist, size=n_draws)) # prior_generalist = pd.Series(np.random.exponential(scale=exp_generalist, size=n_draws))   # Optional: plot prior distributions # plot_priors(prior_specialist, prior_generalist, prior_name) In\u00a0[60]: Copied! <pre># Plot prior distributions\nplot_priors(prior_specialist, prior_generalist, prior_name, save=True)\n\n# Option to save ABM matrices for each iteration\nsave_abm_matrices = False  # Set to True to enable saving\n</pre> # Plot prior distributions plot_priors(prior_specialist, prior_generalist, prior_name, save=True)  # Option to save ABM matrices for each iteration save_abm_matrices = False  # Set to True to enable saving  In\u00a0[57]: Copied! <pre># Run simulation over multiple draws ---\n\nall_deg_pol = pd.DataFrame()\nall_deg_pla = pd.DataFrame()\n</pre> # Run simulation over multiple draws ---  all_deg_pol = pd.DataFrame() all_deg_pla = pd.DataFrame()    In\u00a0[58]: Copied! <pre>for i in range(n_draws):\n    \n    # Generate initial pollinators with random distribution\n    generalists, df_polPM = initial_pollinators_random(\n        dist_pol, n_pollinators,\n        xmin, xmax, ymin, ymax\n    )\n    \n    #generalistas,df_polPM = initial_pollinators(dist_pol, n_pollinators, xmin, xmax, ymin, ymax)\n    #generalistas,df_polPM = initial_pollinators_random(dist_pol, n_pollinators, xmin, xmax, ymin, ymax,random_distribution=True)\n\n    # Assign interaction radius from prior (same for both types here)\n    df_polPM.loc[df_polPM['Tipo'] == 'Especialista', 'Radius'] = prior_specialist[i]\n    df_polPM.loc[df_polPM['Tipo'] == 'Generalista', 'Radius'] = prior_specialist[i]\n    #df_polPM.loc[df_polPM['Tipo'] == 'Generalista', 'Radius'] = prior_generalist[i]\n\n    # Initialize pollinator environment\n    envpol = Environment_pol(df_polPM)\n\n    # Create initial bipartite network (pollinator \u00d7 plant)\n    B = initial_network(df_polPM['Pol_id'].tolist(), df_plant_pm['Plant_id'].tolist())\n\n    # Assign interactions based on distance constraints\n    update_totalinks(nt_links, envpol, envp, B, xmin, xmax, ymin, ymax)\n\n    # Remove agents with no links\n    remove_zero(B)\n\n    # Extract plant-pollinator submatrix\n    B_df = to_pandas_adjacency(B)\n    df_ABM = B_df.iloc[:-len(df_plant_pm), len(df_polPM):]  # [pollinators, plants]\n\n    # Annotate ABM matrix with species\n    df_ABM['Sp_pol'] = df_ABM.index.map(df_polPM.set_index('Pol_id')['Specie'])\n    df_ABM.loc['Sp_plant'] = df_ABM.columns.map(df_plant_pm.set_index('Plant_id')['Plant_sp'])\n\n    # Optionally save ABM matrix for this iteration\n    if save_abm_matrices:\n        abm_path = os.path.join(output_dir, f\"{i}_{output_filename}_{prior_name}_ABM.csv\")\n        df_ABM.to_csv(abm_path)\n\n    # Aggregate pollinator links by species\n    df_species = df_ABM.groupby('Sp_pol').sum()\n\n    # Transpose to get plant \u00d7 pollinator species matrix (model)\n    df_model = df_species.T\n\n    # Real interaction matrix (based on input network)\n    df_real = df_net.set_index('Plant_id')\n\n    # --- Degree distributions ---\n\n    pol_d_model, plant_d_model = degree_dist(df_model)\n    pol_d_real, plant_d_real = degree_dist(df_real)\n\n    # Merge plant degree distributions\n    plant_d_model.index = plant_d_model.index.map(str)\n    plant_d_real.index = plant_d_real.index.map(str)\n    index_union = plant_d_real.index.union(plant_d_model.index)\n\n    deg_plant = pd.DataFrame(index=index_union)\n    deg_plant['Model'] = plant_d_model\n    deg_plant['Real'] = plant_d_real\n    deg_plant = deg_plant.fillna(0)\n\n    # Merge pollinator degree distributions\n    deg_pol = pd.concat([pol_d_model, pol_d_real], axis=1, keys=['Model', 'Real'])\n    deg_pol = deg_pol.fillna(0)\n\n    # Add metadata\n    deg_pol['iteration'] = i\n    deg_plant['iteration'] = i\n    deg_pol['r_esp'] = prior_specialist[i]\n    deg_pol['r_gen'] = prior_specialist[i]\n    #deg_pol['r_gen'] = prior_generalist[i]\n\n    #box_plot_comp(deg_pol, deg_pla, 'Degree')\n    #KDE_plot_comp(deg_pol, deg_pla, 'Degree')\n\n    # Add pollinator type\n    deg_pol['Tipo'] = deg_pol.index.map(lambda j: 'Generalista' if j in generalists else 'Especialista')\n\n    # Accumulate results\n    all_deg_pol = pd.concat([all_deg_pol, deg_pol])\n    all_deg_pla = pd.concat([all_deg_pla, deg_plant])\n</pre> for i in range(n_draws):          # Generate initial pollinators with random distribution     generalists, df_polPM = initial_pollinators_random(         dist_pol, n_pollinators,         xmin, xmax, ymin, ymax     )          #generalistas,df_polPM = initial_pollinators(dist_pol, n_pollinators, xmin, xmax, ymin, ymax)     #generalistas,df_polPM = initial_pollinators_random(dist_pol, n_pollinators, xmin, xmax, ymin, ymax,random_distribution=True)      # Assign interaction radius from prior (same for both types here)     df_polPM.loc[df_polPM['Tipo'] == 'Especialista', 'Radius'] = prior_specialist[i]     df_polPM.loc[df_polPM['Tipo'] == 'Generalista', 'Radius'] = prior_specialist[i]     #df_polPM.loc[df_polPM['Tipo'] == 'Generalista', 'Radius'] = prior_generalist[i]      # Initialize pollinator environment     envpol = Environment_pol(df_polPM)      # Create initial bipartite network (pollinator \u00d7 plant)     B = initial_network(df_polPM['Pol_id'].tolist(), df_plant_pm['Plant_id'].tolist())      # Assign interactions based on distance constraints     update_totalinks(nt_links, envpol, envp, B, xmin, xmax, ymin, ymax)      # Remove agents with no links     remove_zero(B)      # Extract plant-pollinator submatrix     B_df = to_pandas_adjacency(B)     df_ABM = B_df.iloc[:-len(df_plant_pm), len(df_polPM):]  # [pollinators, plants]      # Annotate ABM matrix with species     df_ABM['Sp_pol'] = df_ABM.index.map(df_polPM.set_index('Pol_id')['Specie'])     df_ABM.loc['Sp_plant'] = df_ABM.columns.map(df_plant_pm.set_index('Plant_id')['Plant_sp'])      # Optionally save ABM matrix for this iteration     if save_abm_matrices:         abm_path = os.path.join(output_dir, f\"{i}_{output_filename}_{prior_name}_ABM.csv\")         df_ABM.to_csv(abm_path)      # Aggregate pollinator links by species     df_species = df_ABM.groupby('Sp_pol').sum()      # Transpose to get plant \u00d7 pollinator species matrix (model)     df_model = df_species.T      # Real interaction matrix (based on input network)     df_real = df_net.set_index('Plant_id')      # --- Degree distributions ---      pol_d_model, plant_d_model = degree_dist(df_model)     pol_d_real, plant_d_real = degree_dist(df_real)      # Merge plant degree distributions     plant_d_model.index = plant_d_model.index.map(str)     plant_d_real.index = plant_d_real.index.map(str)     index_union = plant_d_real.index.union(plant_d_model.index)      deg_plant = pd.DataFrame(index=index_union)     deg_plant['Model'] = plant_d_model     deg_plant['Real'] = plant_d_real     deg_plant = deg_plant.fillna(0)      # Merge pollinator degree distributions     deg_pol = pd.concat([pol_d_model, pol_d_real], axis=1, keys=['Model', 'Real'])     deg_pol = deg_pol.fillna(0)      # Add metadata     deg_pol['iteration'] = i     deg_plant['iteration'] = i     deg_pol['r_esp'] = prior_specialist[i]     deg_pol['r_gen'] = prior_specialist[i]     #deg_pol['r_gen'] = prior_generalist[i]      #box_plot_comp(deg_pol, deg_pla, 'Degree')     #KDE_plot_comp(deg_pol, deg_pla, 'Degree')      # Add pollinator type     deg_pol['Tipo'] = deg_pol.index.map(lambda j: 'Generalista' if j in generalists else 'Especialista')      # Accumulate results     all_deg_pol = pd.concat([all_deg_pol, deg_pol])     all_deg_pla = pd.concat([all_deg_pla, deg_plant]) In\u00a0[59]: Copied! <pre># --- Save aggregated degree distributions ---\n\ndeg_pol_path = os.path.join(output_dir, f\"{output_filename}_{prior_name}_species_deg_pol_model2.csv\")\ndeg_pla_path = os.path.join(output_dir, f\"{output_filename}_{prior_name}_species_deg_pla_model2.csv\")\n\nall_deg_pol.to_csv(deg_pol_path)\nall_deg_pla.to_csv(deg_pla_path)\n</pre> # --- Save aggregated degree distributions ---  deg_pol_path = os.path.join(output_dir, f\"{output_filename}_{prior_name}_species_deg_pol_model2.csv\") deg_pla_path = os.path.join(output_dir, f\"{output_filename}_{prior_name}_species_deg_pla_model2.csv\")  all_deg_pol.to_csv(deg_pol_path) all_deg_pla.to_csv(deg_pla_path) In\u00a0[63]: Copied! <pre>from visualization import plot_agents\n\n# 1. Visualize initial agent positions\nax = plot_agents(envp, envpol, selected_plot, slice_index, xmin, xmax, ymin, ymax, save=False)\n</pre> from visualization import plot_agents  # 1. Visualize initial agent positions ax = plot_agents(envp, envpol, selected_plot, slice_index, xmin, xmax, ymin, ymax, save=False)  In\u00a0[64]: Copied! <pre># 1. Visualize initial agent positions\nax1 = plot_agents(envp_regular, envpol, selected_plot, slice_index, xmin, xmax, ymin, ymax, save=False)\n</pre> # 1. Visualize initial agent positions ax1 = plot_agents(envp_regular, envpol, selected_plot, slice_index, xmin, xmax, ymin, ymax, save=False)  In\u00a0[29]: Copied! <pre>import glob\nfrom abc_module.metrics import compute_metrics, top_metric, resume_error, plot_degree_comp\n\n# Reading the file\n#file_pattern = 'Output_analysis/*random_deg_pol_randomproof.csv'\nfile_pattern = 'Output_analysis/*species_deg_pol_model2.csv'\n#file_pattern = 'Output_analysis/A*species_deg_pol_model2.csv'\n#file_pattern = 'Output_analysis/*regular_deg_pol.csv'\n#file_pattern = 'Output_analysis/*XY_deg_pol.csv'\n#file_pattern = 'Output_analysis/*random_deg_pol.csv'\n</pre> import glob from abc_module.metrics import compute_metrics, top_metric, resume_error, plot_degree_comp  # Reading the file #file_pattern = 'Output_analysis/*random_deg_pol_randomproof.csv' file_pattern = 'Output_analysis/*species_deg_pol_model2.csv' #file_pattern = 'Output_analysis/A*species_deg_pol_model2.csv' #file_pattern = 'Output_analysis/*regular_deg_pol.csv' #file_pattern = 'Output_analysis/*XY_deg_pol.csv' #file_pattern = 'Output_analysis/*random_deg_pol.csv'  In\u00a0[30]: Copied! <pre># Find all files that match the pattern\nfile_list = glob.glob(file_pattern)\nprint(file_list)\n</pre> # Find all files that match the pattern file_list = glob.glob(file_pattern) print(file_list) <pre>['Output_analysis/A3_nd100__gamma_s2_5_sc2_1_species_deg_pol_model2.csv']\n</pre> In\u00a0[33]: Copied! <pre>abs_errors = []  # list to save errors\n\nfor file_name in file_list:\n    print(file_name)\n    plot_month= file_name.split('/')[-1]\n    pm = plot_month.split('_')[0]\n    model = plot_month.split('_')[-1]\n    data = pd.read_csv(file_name)\n    metrics_df = compute_metrics(data)\n\n    metrics = [\"JS_divergence\", \"KS_distance\", \"Wasserstein_distance\", \n           \"Hellinger_distance\", \"Relative_MAE\", \"Absolute_MAE\",\"KL_divergence\"]\n    \n    top_dfs = {metric: top_metric(metrics_df, metric, top_fraction=0.1) for metric in metrics}\n\n\n    # Diccionario que mapea m\u00e9tricas a etiquetas personalizadas para el plot\n    metric_labels = {\n        'Absolute_MAE': 'MAE',\n        'Relative_MAE': 'RMAE',\n        'JS_divergence': 'JS',\n        'KS_distance': 'KS',\n        'Wasserstein_distance': 'WASS',\n        'Hellinger_distance': 'HELL',\n        'KL_divergence': 'KL'  \n    }\n   \n\n    for metric, label in metric_labels.items():\n        if metric in top_dfs:\n            name = label + '_'+ pm + '_' + model\n            top_iterations = top_dfs[metric].iteration.values\n            filtered_data = data[data['iteration'].isin(top_iterations)].copy()\n            summary = resume_error(filtered_data)\n            summary['metric'] = label\n            summary['plot'] = name\n            abs_errors.append(summary)\n            # Opcional: generar gr\u00e1fica\n            plot_degree_comp(filtered_data, name)\n            plt.savefig(f\"{name}.png\", dpi=300)\n            #total_error = plot_degree_comp(filtered_data, name)\n            #abs_errors.append({'metric': label, 'plot': name, 'total_abs_error': summary})\n            #plt.savefig(f\"{name}.png\", dpi=300)\n</pre>  abs_errors = []  # list to save errors  for file_name in file_list:     print(file_name)     plot_month= file_name.split('/')[-1]     pm = plot_month.split('_')[0]     model = plot_month.split('_')[-1]     data = pd.read_csv(file_name)     metrics_df = compute_metrics(data)      metrics = [\"JS_divergence\", \"KS_distance\", \"Wasserstein_distance\",             \"Hellinger_distance\", \"Relative_MAE\", \"Absolute_MAE\",\"KL_divergence\"]          top_dfs = {metric: top_metric(metrics_df, metric, top_fraction=0.1) for metric in metrics}       # Diccionario que mapea m\u00e9tricas a etiquetas personalizadas para el plot     metric_labels = {         'Absolute_MAE': 'MAE',         'Relative_MAE': 'RMAE',         'JS_divergence': 'JS',         'KS_distance': 'KS',         'Wasserstein_distance': 'WASS',         'Hellinger_distance': 'HELL',         'KL_divergence': 'KL'       }          for metric, label in metric_labels.items():         if metric in top_dfs:             name = label + '_'+ pm + '_' + model             top_iterations = top_dfs[metric].iteration.values             filtered_data = data[data['iteration'].isin(top_iterations)].copy()             summary = resume_error(filtered_data)             summary['metric'] = label             summary['plot'] = name             abs_errors.append(summary)             # Opcional: generar gr\u00e1fica             plot_degree_comp(filtered_data, name)             plt.savefig(f\"{name}.png\", dpi=300)             #total_error = plot_degree_comp(filtered_data, name)             #abs_errors.append({'metric': label, 'plot': name, 'total_abs_error': summary})             #plt.savefig(f\"{name}.png\", dpi=300)   <pre>Output_analysis/A3_nd100__gamma_s2_5_sc2_1_species_deg_pol_model2.csv\n</pre> In\u00a0[\u00a0]: Copied! <pre>abs_errors_path = os.path.join(output_dir, f'abserrors_zscore_{model}')\n\ndf_abs_errors = pd.concat(abs_errors, ignore_index=True)\ndf_abs_errors.to_csv(abs_errors_path )\n</pre> abs_errors_path = os.path.join(output_dir, f'abserrors_zscore_{model}')  df_abs_errors = pd.concat(abs_errors, ignore_index=True) df_abs_errors.to_csv(abs_errors_path )"},{"location":"usage/example/#visualization-of-the-initial-positions-of-agents","title":"Visualization of the initial positions of agents\u00b6","text":"<p>In this section we show how plants and pollinators are spatially distributed at the start of the simulation.</p> <p>Depending on how the environment (<code>Environment_plant</code>) is initialized, plants can be:</p> <ul> <li>At the coordinates provided in the original DataFrame.</li> <li>Distributed randomly within the defined spatial boundaries.</li> <li>Arranged on a regular grid within the boundaries.</li> </ul> <p>Pollinators, on the other hand, are initialized according to the abundance distributions defined in the model.</p> <p>The following plot shows the initial locations of both groups of agents.</p>"},{"location":"usage/example/#bayesian-analysis","title":"Bayesian analysis\u00b6","text":""}]}